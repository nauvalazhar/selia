{"version":3,"sources":["../src/commands/add.ts"],"sourcesContent":["// commands/add.ts\nimport { Command } from 'commander';\nimport { intro, outro, spinner, log, select } from '@clack/prompts';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { loadConfig } from '~/lib/load-config';\nimport { fetchItems } from '~/lib/fetch-item';\nimport { resolveDependencies } from '~/lib/resolve-dependencies';\nimport { resolveImportAlias, resolveTargetPath } from '~/lib/resolve-import';\nimport { installDependencies } from '~/lib/install-dependencies';\nimport { abortIfCancel, getRegistryFromConfig } from '~/lib/utils';\nimport picocolors from 'picocolors';\n\nimport { existsSync } from 'fs';\n\nexport const addCommand = new Command()\n  .name('add')\n  .description('Add components to your project')\n  .argument('<items...>', 'Items to add')\n  .option('-y, --yes', 'Skip confirmation prompts')\n  .option('--no-install', 'Skip installing dependencies')\n  .option('--overwrite', 'Overwrite existing files without asking')\n  .action(async (itemNames: string[], options) => {\n    console.log();\n    intro(picocolors.bgBlue(picocolors.blackBright(' Add Item ')));\n\n    log.warn(\n      picocolors.yellow(\n        'The CLI is still in development, report any issues on GitHub!',\n      ),\n    );\n\n    try {\n      const config = await loadConfig();\n      const s = spinner();\n      const registry = getRegistryFromConfig(config);\n\n      if (!registry?.url) {\n        log.error(picocolors.red('Registry not found'));\n        return;\n      }\n\n      //   s.start(`Fetching ${itemNames.length} item(s) from registry...`);\n      const items = await fetchItems(registry.url, itemNames);\n      //   s.stop(`Fetched ${items.length} item(s)`);\n\n      s.start('Resolving dependencies...');\n      const resolved = await resolveDependencies(items, registry.url);\n      s.stop(\n        `Resolved ${resolved.items.size} item(s) and ${Object.keys(resolved.npmPackages).length} npm package(s)`,\n      );\n\n      const allItems = Array.from(resolved.items.values());\n      const npmPackages = resolved.npmPackages;\n\n      // Check for existing files\n      const existingFiles: string[] = [];\n      const filesToWrite: Array<{\n        item: (typeof allItems)[0];\n        file: (typeof allItems)[0]['files'][0];\n        targetPath: string;\n        content: string;\n      }> = [];\n\n      for (const item of allItems) {\n        for (const file of item.files) {\n          const basePath = resolveTargetPath(\n            file.target,\n            config,\n            process.cwd(),\n          );\n          const targetPath = path.join(basePath, file.name);\n\n          let content = file.content || '';\n          content = resolveImportAlias(content, config);\n\n          filesToWrite.push({ item, file, targetPath, content });\n\n          if (existsSync(targetPath)) {\n            existingFiles.push(path.relative(process.cwd(), targetPath));\n          }\n        }\n      }\n\n      // Handle existing files\n      if (existingFiles.length > 0 && !options.overwrite) {\n        log.warn(`Found ${existingFiles.length} existing file(s):`);\n        existingFiles.forEach((f) =>\n          console.log(`  ${picocolors.yellow('•')} ${f}`),\n        );\n        console.log();\n\n        const overwriteChoice = await select({\n          message: 'How do you want to proceed?',\n          options: [\n            { value: 'overwrite', label: 'Overwrite all existing files' },\n            { value: 'skip', label: 'Skip existing files' },\n            { value: 'cancel', label: 'Cancel operation' },\n          ],\n        });\n\n        abortIfCancel(overwriteChoice);\n\n        if (overwriteChoice === 'cancel') {\n          outro('Cancelled');\n          process.exit(0);\n        }\n\n        if (overwriteChoice === 'skip') {\n          // Filter out existing files\n          const skippedCount = filesToWrite.length;\n          filesToWrite.splice(\n            0,\n            filesToWrite.length,\n            ...filesToWrite.filter((f) => !existsSync(f.targetPath)),\n          );\n          log.info(\n            `Skipping ${skippedCount - filesToWrite.length} existing file(s)`,\n          );\n        }\n      }\n\n      // Write files\n      if (filesToWrite.length === 0) {\n        log.warn('No files to write');\n        outro('Done');\n        return;\n      }\n\n      s.start('Writing files...');\n      let filesWritten = 0;\n\n      for (const { targetPath, content } of filesToWrite) {\n        await fs.mkdir(path.dirname(targetPath), { recursive: true });\n        await fs.writeFile(targetPath, content, 'utf-8');\n        filesWritten++;\n      }\n\n      s.stop(`Wrote ${filesWritten} file(s)`);\n\n      // Install npm dependencies\n      if (options.install && Object.keys(npmPackages).length > 0) {\n        await installDependencies(npmPackages);\n      }\n\n      outro('Components added successfully! ✓');\n    } catch (error) {\n      log.error(\n        picocolors.red(\n          error instanceof Error ? error.message : 'An unknown error occurred',\n        ),\n      );\n      process.exit(1);\n    }\n  });\n"],"mappings":"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","names":[]}