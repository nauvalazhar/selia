{"version":3,"sources":["../src/index.ts","../src/commands/add.ts","../src/lib/load-config.ts","../src/schemas/config-schema.ts","../src/lib/default-config.ts","../src/schemas/item-schema.ts","../src/lib/fetch-item.ts","../src/lib/resolve-dependencies.ts","../src/lib/resolve-import.ts","../src/lib/install-dependencies.ts","../src/lib/package-manager.ts","../src/lib/check-workspace.ts","../src/lib/utils.ts","../src/lib/resolve-registry.ts","../src/commands/init.ts","../src/schemas/setup-schema.ts","../src/lib/fetch-setup.ts","../src/lib/setup-executor.ts","../src/lib/detect-framework.ts","../src/lib/detect-workdir.ts","../src/lib/write-config.ts","../src/commands/build.ts","../src/schemas/registry-schema.ts","../src/lib/clean-build.ts","../src/lib/build-registry.ts"],"sourcesContent":["#!/usr/bin/env node\r\nimport { program } from 'commander';\r\nimport { addCommand } from '~/commands/add';\r\nimport { initCommand } from '~/commands/init';\r\nimport { buildCommand } from '~/commands/build';\r\n\r\nprogram.version('0.0.1');\r\n\r\nprogram.addCommand(initCommand);\r\nprogram.addCommand(addCommand);\r\nprogram.addCommand(buildCommand);\r\n\r\nprogram.parse();\r\n","// commands/add.ts\r\nimport { Command } from 'commander';\r\nimport { intro, outro, spinner, log, select } from '@clack/prompts';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { loadConfig } from '~/lib/load-config';\r\nimport { fetchItems } from '~/lib/fetch-item';\r\nimport { resolveDependencies } from '~/lib/resolve-dependencies';\r\nimport { resolveImportAlias, resolveTargetPath } from '~/lib/resolve-import';\r\nimport { installDependencies } from '~/lib/install-dependencies';\r\nimport { abortIfCancel } from '~/lib/utils';\r\nimport picocolors from 'picocolors';\r\n\r\nimport { existsSync } from 'fs';\r\nimport { resolveRegistry } from '~/lib/resolve-registry';\r\n\r\nexport const addCommand = new Command()\r\n  .name('add')\r\n  .description('Add components to your project')\r\n  .argument('<items...>', 'Items to add')\r\n  .option('-y, --yes', 'Skip confirmation prompts')\r\n  .option('--no-install', 'Skip installing dependencies')\r\n  .option('--overwrite', 'Overwrite existing files without asking')\r\n  .action(async (itemNames: string[], options) => {\r\n    console.log();\r\n    intro(picocolors.bgBlue(picocolors.blackBright(' Add Item ')));\r\n\r\n    log.warn(\r\n      picocolors.yellow(\r\n        'The CLI is still in development, report any issues on GitHub!',\r\n      ),\r\n    );\r\n\r\n    // check config file\r\n    if (!existsSync(path.join(process.cwd(), 'selia.json'))) {\r\n      log.error(\r\n        picocolors.red('You can only use this command in a Selia project.'),\r\n      );\r\n      console.log();\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const config = await loadConfig();\r\n      const s = spinner();\r\n      const { runtimeUrl: registryUrl } = await resolveRegistry(process.cwd());\r\n\r\n      if (!registryUrl) {\r\n        log.error(picocolors.red('Registry not found'));\r\n        return;\r\n      }\r\n\r\n      //   s.start(`Fetching ${itemNames.length} item(s) from registry...`);\r\n      const items = await fetchItems(registryUrl, itemNames);\r\n      //   s.stop(`Fetched ${items.length} item(s)`);\r\n\r\n      s.start('Resolving dependencies...');\r\n      const resolved = await resolveDependencies(items, registryUrl);\r\n      s.stop(\r\n        `Resolved ${resolved.items.size} item(s) and ${Object.keys(resolved.npmPackages).length} npm package(s)`,\r\n      );\r\n\r\n      const allItems = Array.from(resolved.items.values());\r\n      const npmPackages = resolved.npmPackages;\r\n\r\n      // Check for existing files\r\n      const existingFiles: string[] = [];\r\n      const filesToWrite: Array<{\r\n        item: (typeof allItems)[0];\r\n        file: (typeof allItems)[0]['files'][0];\r\n        targetPath: string;\r\n        content: string;\r\n      }> = [];\r\n\r\n      for (const item of allItems) {\r\n        for (const file of item.files) {\r\n          const basePath = resolveTargetPath(\r\n            file.target,\r\n            config,\r\n            process.cwd(),\r\n          );\r\n          const targetPath = path.join(basePath, file.name);\r\n\r\n          let content = file.content || '';\r\n          content = resolveImportAlias(content, config);\r\n\r\n          filesToWrite.push({ item, file, targetPath, content });\r\n\r\n          if (existsSync(targetPath)) {\r\n            existingFiles.push(path.relative(process.cwd(), targetPath));\r\n          }\r\n        }\r\n      }\r\n\r\n      // Handle existing files\r\n      if (existingFiles.length > 0 && !options.overwrite) {\r\n        log.warn(`Found ${existingFiles.length} existing file(s):`);\r\n        existingFiles.forEach((f) =>\r\n          console.log(`  ${picocolors.yellow('•')} ${f}`),\r\n        );\r\n        console.log();\r\n\r\n        const overwriteChoice = await select({\r\n          message: 'How do you want to proceed?',\r\n          initialValue: 'skip',\r\n          options: [\r\n            { value: 'overwrite', label: 'Overwrite all existing files' },\r\n            { value: 'skip', label: 'Skip existing files' },\r\n            { value: 'cancel', label: 'Cancel operation' },\r\n          ],\r\n        });\r\n\r\n        abortIfCancel(overwriteChoice);\r\n\r\n        if (overwriteChoice === 'cancel') {\r\n          outro('Cancelled');\r\n          process.exit(0);\r\n        }\r\n\r\n        if (overwriteChoice === 'skip') {\r\n          // Filter out existing files\r\n          const skippedCount = filesToWrite.length;\r\n          filesToWrite.splice(\r\n            0,\r\n            filesToWrite.length,\r\n            ...filesToWrite.filter((f) => !existsSync(f.targetPath)),\r\n          );\r\n          log.info(\r\n            `Skipping ${skippedCount - filesToWrite.length} existing file(s)`,\r\n          );\r\n        }\r\n      }\r\n\r\n      // Write files\r\n      if (filesToWrite.length === 0) {\r\n        log.warn('No files to write');\r\n        outro('Done');\r\n        return;\r\n      }\r\n\r\n      s.start('Writing files...');\r\n      let filesWritten = 0;\r\n\r\n      for (const { targetPath, content } of filesToWrite) {\r\n        await fs.mkdir(path.dirname(targetPath), { recursive: true });\r\n        await fs.writeFile(targetPath, content, 'utf-8');\r\n        filesWritten++;\r\n      }\r\n\r\n      s.stop(`Wrote ${filesWritten} file(s)`);\r\n\r\n      // Install npm dependencies\r\n      if (options.install && Object.keys(npmPackages).length > 0) {\r\n        await installDependencies(npmPackages);\r\n      }\r\n\r\n      outro('Components added successfully! ✓');\r\n    } catch (error) {\r\n      log.error(\r\n        picocolors.red(\r\n          error instanceof Error ? error.message : 'An unknown error occurred',\r\n        ),\r\n      );\r\n      process.exit(1);\r\n    }\r\n  });\r\n","import fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { ConfigSchema, type Config } from '../schemas/config-schema';\r\nimport { defaultConfig } from '~/lib/default-config';\r\nimport defu from 'defu';\r\nimport { log } from '@clack/prompts';\r\nimport z from 'zod';\r\n\r\nexport async function loadConfig(cwd: string = process.cwd()): Promise<Config> {\r\n  const configPath = path.join(cwd, 'selia.json');\r\n\r\n  try {\r\n    const content = await fs.readFile(configPath, 'utf-8');\r\n    const data = JSON.parse(content);\r\n\r\n    const merged = defu(data, defaultConfig);\r\n\r\n    const config = ConfigSchema.parse(merged);\r\n\r\n    log.info(`Loaded config from ${path.relative(cwd, configPath)}`);\r\n\r\n    return config;\r\n  } catch (error) {\r\n    if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {\r\n      log.warn(\r\n        `No config file found at ${path.relative(cwd, configPath)} (using default config)`,\r\n      );\r\n\r\n      return defaultConfig;\r\n    }\r\n\r\n    if (error instanceof SyntaxError) {\r\n      throw new Error(\r\n        `Invalid JSON in config file ${configPath}: ${error.message}`,\r\n      );\r\n    }\r\n\r\n    if (error instanceof z.ZodError) {\r\n      throw new Error(\r\n        `Invalid config format:\\n${error.issues.map((e) => `  - ${e.path.join('.')}: ${e.message}`).join('\\n')}`,\r\n      );\r\n    }\r\n\r\n    throw new Error(\r\n      `Failed to load config from ${configPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n    );\r\n  }\r\n}\r\n","import { z } from 'zod';\r\n\r\nexport const ConfigSchema = z.object({\r\n  framework: z.string().optional(),\r\n  paths: z.record(z.string(), z.string()),\r\n  imports: z.record(z.string(), z.string()),\r\n  registries: z\r\n    .object({\r\n      default: z.string().optional(),\r\n      sources: z\r\n        .record(\r\n          z.string(),\r\n          z.object({\r\n            name: z.string(),\r\n            url: z.url(),\r\n            homepage: z.url().optional(),\r\n          }),\r\n        )\r\n        .optional(),\r\n    })\r\n    .optional(),\r\n});\r\n\r\nexport type Config = z.infer<typeof ConfigSchema>;\r\n","import { Config } from '../schemas/config-schema';\r\n\r\nexport const defaultConfig = {\r\n  framework: 'react',\r\n  paths: {\r\n    components: 'components/selia',\r\n    utils: 'lib/utils.ts',\r\n  },\r\n  imports: {\r\n    utils: '@/lib/utils',\r\n    components: '@/components/selia',\r\n  },\r\n} satisfies Config;\r\n","import { z } from 'zod';\r\n\r\nexport const ItemSchema = z.object({\r\n  name: z.string(),\r\n  type: z.union([\r\n    z.enum(['component', 'block', 'hook', 'util', 'config']),\r\n    z.string(),\r\n  ]),\r\n  dependencies: z\r\n    .object({\r\n      npm: z.record(z.string(), z.string()).optional(),\r\n      items: z.array(z.string()).optional(),\r\n    })\r\n    .optional(),\r\n  files: z.array(\r\n    z.object({\r\n      name: z.string(),\r\n      content: z.string().optional(),\r\n      target: z.string(),\r\n      path: z.string().optional(),\r\n      type: z\r\n        .union([\r\n          z.enum(['component', 'block', 'hook', 'util', 'config']),\r\n          z.string(),\r\n        ])\r\n        .optional(),\r\n    }),\r\n  ),\r\n});\r\n\r\nexport type Item = z.infer<typeof ItemSchema>;\r\n","import { Item, ItemSchema } from '../schemas/item-schema';\r\n\r\nexport async function fetchItem(\r\n  registryUrl: string,\r\n  itemName: string,\r\n): Promise<Item> {\r\n  const url = `${registryUrl}/${itemName}.json`;\r\n\r\n  try {\r\n    const response = await fetch(url);\r\n\r\n    if (!response.ok) {\r\n      if (response.status === 404) {\r\n        throw new Error(`No item found.`);\r\n      }\r\n\r\n      throw new Error(\r\n        `Failed to fetch item \"${itemName}\" from registry: ${response.statusText}`,\r\n      );\r\n    }\r\n\r\n    const data = await response.json();\r\n    return ItemSchema.parse(data);\r\n  } catch (error) {\r\n    if (error instanceof Error) {\r\n      throw new Error(`Failed to fetch item \"${itemName}\": ${error.message}`);\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function fetchItems(\r\n  registryUrl: string,\r\n  itemNames: string[],\r\n): Promise<Item[]> {\r\n  const items = await Promise.all(\r\n    itemNames.map((name) => fetchItem(registryUrl, name)),\r\n  );\r\n  return items;\r\n}\r\n","import { Item } from '../schemas/item-schema';\r\nimport { fetchItem } from './fetch-item';\r\n\r\ninterface ResolvedDependencies {\r\n  items: Map<string, Item>; // name -> item\r\n  npmPackages: Record<string, string>; // package -> version\r\n}\r\n\r\nexport async function resolveDependencies(\r\n  items: Item[],\r\n  registryUrl: string,\r\n  visited: Set<string> = new Set(),\r\n): Promise<ResolvedDependencies> {\r\n  const result: ResolvedDependencies = {\r\n    items: new Map(),\r\n    npmPackages: {},\r\n  };\r\n\r\n  for (const item of items) {\r\n    // Skip if already processed\r\n    if (visited.has(item.name)) continue;\r\n    visited.add(item.name);\r\n\r\n    // Add current item\r\n    result.items.set(item.name, item);\r\n\r\n    // Collect npm dependencies\r\n    if (item.dependencies?.npm) {\r\n      Object.assign(result.npmPackages, item.dependencies.npm);\r\n    }\r\n\r\n    // Recursively fetch item dependencies\r\n    if (item.dependencies?.items && item.dependencies.items.length > 0) {\r\n      const depItems = await Promise.all(\r\n        item.dependencies.items.map((depName) =>\r\n          fetchItem(registryUrl, depName),\r\n        ),\r\n      );\r\n\r\n      const depResolved = await resolveDependencies(\r\n        depItems,\r\n        registryUrl,\r\n        visited,\r\n      );\r\n\r\n      // Merge results\r\n      for (const [name, depItem] of depResolved.items) {\r\n        result.items.set(name, depItem);\r\n      }\r\n      Object.assign(result.npmPackages, depResolved.npmPackages);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { Config } from '../schemas/config-schema';\r\nimport path from 'path';\r\n\r\nexport function resolveImportAlias(content: string, config: Config): string {\r\n  let resolved = content;\r\n\r\n  const regex = /\\bfrom\\s+(['\"`])(#(\\w+)(?:\\/[^'\"`]*)?)\\1/g;\r\n\r\n  resolved = resolved.replace(regex, (match, quote, fullPath, key) => {\r\n    const target = config.imports[key];\r\n\r\n    if (!target) {\r\n      return match;\r\n    }\r\n\r\n    const replaced = fullPath.replace(`#${key}`, target);\r\n    return `from ${quote}${replaced}${quote}`;\r\n  });\r\n\r\n  return resolved;\r\n}\r\n\r\nexport function resolveTargetPath(\r\n  target: string,\r\n  config: Config,\r\n  cwd: string = process.cwd(),\r\n): string {\r\n  const configPath = config.paths[target as keyof typeof config.paths];\r\n\r\n  if (!configPath) {\r\n    throw new Error(\r\n      `Unknown target \"${target}\". Available targets: ${Object.keys(config.paths).join(', ')}`,\r\n    );\r\n  }\r\n\r\n  return path.join(cwd, configPath);\r\n}\r\n","import { execa } from 'execa';\r\nimport { detectPackageManager, getInstallCommand } from './package-manager';\r\nimport { spinner } from '@clack/prompts';\r\nimport {\r\n  isPnpmWorkspaceRoot,\r\n  isSinglePackageWorkspace,\r\n} from '~/lib/check-workspace';\r\n\r\nexport async function installDependencies(\r\n  packages: Record<string, string>,\r\n  cwd: string = process.cwd(),\r\n): Promise<void> {\r\n  if (Object.keys(packages).length === 0) return;\r\n\r\n  const pm = await detectPackageManager(cwd);\r\n  const packagesString = Object.entries(packages)\r\n    .map(([pkg, version]) => `${pkg}@${version}`)\r\n    .join(' ');\r\n\r\n  const s = spinner();\r\n  s.start(`Installing dependencies with ${pm}...`);\r\n\r\n  try {\r\n    const [command, ...args] = getInstallCommand(pm).split(' ');\r\n\r\n    if (pm === 'pnpm' && (await isPnpmWorkspaceRoot(cwd))) {\r\n      if (!(await isSinglePackageWorkspace(cwd))) {\r\n        throw new Error('You need to install dependencies manually.');\r\n      }\r\n\r\n      args.push('-w');\r\n    }\r\n\r\n    await execa(command, [...args, ...packagesString.split(' ')], {\r\n      cwd,\r\n      args,\r\n      stdio: 'pipe',\r\n    });\r\n\r\n    s.stop('Dependencies installed');\r\n  } catch (error) {\r\n    s.stop('Failed to install dependencies');\r\n    throw new Error(\r\n      `${error instanceof Error ? error.message : 'Unknown error'}`,\r\n    );\r\n  }\r\n}\r\n","// utils/package-manager.ts\r\nimport fs from 'fs/promises';\r\nimport { existsSync } from 'fs';\r\nimport path from 'path';\r\n\r\nexport type PackageManager = 'npm' | 'yarn' | 'pnpm' | 'bun';\r\n\r\nexport async function detectPackageManager(\r\n  cwd: string = process.cwd(),\r\n): Promise<PackageManager> {\r\n  if (existsSync(path.join(cwd, 'bun.lock'))) return 'bun';\r\n  if (existsSync(path.join(cwd, 'pnpm-lock.yaml'))) return 'pnpm';\r\n  if (existsSync(path.join(cwd, 'yarn.lock'))) return 'yarn';\r\n  if (existsSync(path.join(cwd, 'package-lock.json'))) return 'npm';\r\n\r\n  try {\r\n    const pkgPath = path.join(cwd, 'package.json');\r\n    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));\r\n\r\n    if (pkg.packageManager) {\r\n      if (pkg.packageManager.startsWith('bun')) return 'bun';\r\n      if (pkg.packageManager.startsWith('pnpm')) return 'pnpm';\r\n      if (pkg.packageManager.startsWith('yarn')) return 'yarn';\r\n    }\r\n  } catch {}\r\n\r\n  // Default to npm\r\n  return 'npm';\r\n}\r\n\r\nexport function getInstallCommand(pm: PackageManager): string {\r\n  const commands = {\r\n    npm: 'npm install',\r\n    yarn: 'yarn add',\r\n    pnpm: 'pnpm add',\r\n    bun: 'bun add',\r\n  };\r\n  return commands[pm];\r\n}\r\n","import fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { parse } from 'yaml';\r\n\r\nexport async function isSinglePackageWorkspace(cwd: string) {\r\n  try {\r\n    const wsPath = path.join(cwd, 'pnpm-workspace.yaml');\r\n    const raw = await fs.readFile(wsPath, 'utf-8');\r\n    const ws = parse(raw);\r\n\r\n    const packages = ws?.packages ?? [];\r\n\r\n    return (\r\n      packages.length === 1 && (packages[0] === '.' || packages[0] === './')\r\n    );\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function isPnpmWorkspaceRoot(cwd: string): Promise<boolean> {\r\n  try {\r\n    await fs.access(path.join(cwd, 'pnpm-workspace.yaml'));\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n","import fs from 'fs/promises';\r\nimport { Config } from '../schemas/config-schema';\r\nimport { cancel, isCancel } from '@clack/prompts';\r\n\r\nexport async function isRegistryExists() {\r\n  try {\r\n    await fs.access('./registry.json');\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function getRegistryFromConfig(config: Config) {\r\n  if (!config.registries?.default || !config.registries.sources) {\r\n    return null;\r\n  }\r\n\r\n  const registry = config.registries.sources[config.registries.default];\r\n\r\n  if (!registry) {\r\n    return null;\r\n  }\r\n\r\n  return registry;\r\n}\r\n\r\nexport function abortIfCancel(value: unknown): never | void {\r\n  if (isCancel(value)) {\r\n    cancel('Setup aborted by user.');\r\n    process.exit(1);\r\n  }\r\n}\r\n","import fs from 'fs/promises';\r\nimport path from 'path';\r\n\r\nexport interface ResolveRegistryResult {\r\n  runtimeUrl: string;\r\n  persist: boolean;\r\n  existingConfig: any | null;\r\n}\r\n\r\nexport async function resolveRegistry(\r\n  cwd: string,\r\n  cliRegistry?: string,\r\n): Promise<ResolveRegistryResult> {\r\n  const configPath = path.join(cwd, 'selia.json');\r\n\r\n  let existingConfig: any = null;\r\n  try {\r\n    existingConfig = JSON.parse(await fs.readFile(configPath, 'utf-8'));\r\n  } catch {}\r\n\r\n  const isDev =\r\n    process.env.SELIA_DEV === '1' || process.env.NODE_ENV === 'development';\r\n\r\n  const defaultRegistry = isDev\r\n    ? 'http://localhost:5173/registry'\r\n    : 'https://selia.nauv.al/registry';\r\n\r\n  const runtimeUrl =\r\n    cliRegistry ||\r\n    existingConfig?.registries?.sources?.selia?.url ||\r\n    defaultRegistry;\r\n\r\n  const persist =\r\n    Boolean(cliRegistry) && !existingConfig?.registries?.sources?.selia;\r\n\r\n  return {\r\n    runtimeUrl,\r\n    persist,\r\n    existingConfig,\r\n  };\r\n}\r\n","import { Command } from 'commander';\r\nimport { intro, outro, log, spinner, note, confirm } from '@clack/prompts';\r\nimport picocolors from 'picocolors';\r\nimport { fetchSetup } from '~/lib/fetch-setup';\r\nimport {\r\n  executeSetup,\r\n  executeSetupActions,\r\n  previewSetupActions,\r\n} from '~/lib/setup-executor';\r\nimport { defaultConfig } from '~/lib/default-config';\r\nimport { resolveRegistry } from '~/lib/resolve-registry';\r\nimport { writeConfig } from '~/lib/write-config';\r\nimport { Config } from '~/schemas/config-schema';\r\nimport { abortIfCancel } from '~/lib/utils';\r\n\r\nexport const initCommand = new Command()\r\n  .name('init')\r\n  .description('Initialize Selia in your project')\r\n  .option('-r, --registry <url>', 'Registry URL')\r\n  .option('-y, --yes', 'Skip confirmation')\r\n  .action(async (options) => {\r\n    console.log();\r\n    intro(picocolors.bgBlue(picocolors.blackBright(' Initialize Selia ')));\r\n\r\n    log.warn(\r\n      picocolors.yellow(\r\n        'The CLI is still in development, report any issues on GitHub!',\r\n      ),\r\n    );\r\n\r\n    if (options.registry) {\r\n      log.info(\r\n        'This feature is not available yet.\\nUse default Selia registry instead.',\r\n      );\r\n      console.log();\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const { runtimeUrl } = await resolveRegistry(\r\n        process.cwd(),\r\n        options.registry,\r\n      );\r\n\r\n      const registryUrl = runtimeUrl;\r\n      if (!registryUrl) {\r\n        outro('Cancelled.');\r\n        return;\r\n      }\r\n\r\n      const s = spinner();\r\n\r\n      // Try to fetch setup.json\r\n      let setup;\r\n      try {\r\n        s.start('Fetching setup configuration...');\r\n        setup = await fetchSetup(registryUrl as string);\r\n        s.stop('Setup configuration loaded');\r\n      } catch (error) {\r\n        if (error instanceof Error) {\r\n          s.stop(error.message);\r\n          return;\r\n        }\r\n\r\n        s.stop('No setup configuration found');\r\n\r\n        const finalConfig = {\r\n          ...defaultConfig,\r\n        } as Config;\r\n\r\n        await writeConfig(finalConfig);\r\n\r\n        outro(picocolors.green('Config created ✓'));\r\n        log.info(\r\n          'Run ' +\r\n            picocolors.cyan('selia add <component>') +\r\n            ' to add components',\r\n        );\r\n        console.log();\r\n        return;\r\n      }\r\n\r\n      // Execute setup prompts (Phase 1: Collect info)\r\n      const context = await executeSetup(setup);\r\n\r\n      // Preview actions\r\n      const actions = await previewSetupActions(setup, context);\r\n\r\n      // Always add config creation action\r\n      actions.unshift('Create `selia.json`');\r\n\r\n      // Show what will be done\r\n      log.info('I will now perform the following actions:');\r\n      actions.forEach((action) => {\r\n        console.log(picocolors.dim('  • ') + action);\r\n      });\r\n\r\n      // Confirm\r\n      if (!options.yes) {\r\n        const shouldContinue = await confirm({\r\n          message: 'Is this okay?',\r\n          initialValue: true,\r\n        });\r\n\r\n        abortIfCancel(shouldContinue);\r\n\r\n        if (!shouldContinue) {\r\n          outro('Cancelled. Nothing was done.');\r\n          process.exit(0);\r\n        }\r\n      }\r\n\r\n      // Execute actions (Phase 2: Do the work)\r\n      await executeSetupActions(setup, context);\r\n\r\n      // Build final config\r\n      const config = context as Config;\r\n\r\n      // Write config file\r\n      s.start('Creating config file...');\r\n      await writeConfig(config);\r\n      s.stop('Config file created');\r\n\r\n      // Show summary\r\n      note(picocolors.dim('Config saved to: ') + picocolors.cyan('selia.json'));\r\n\r\n      log.info(picocolors.green('Selia initialized successfully! ✓'));\r\n      outro(\r\n        'Run ' +\r\n          picocolors.cyan('selia add <component>') +\r\n          ' to add components',\r\n      );\r\n      console.log();\r\n    } catch (error) {\r\n      log.error(\r\n        error instanceof Error ? error.message : 'An unknown error occurred',\r\n      );\r\n      console.log();\r\n      process.exit(1);\r\n    }\r\n  });\r\n","import { z } from 'zod';\r\n\r\nconst ConditionAtomSchema = z.discriminatedUnion('type', [\r\n  z.object({\r\n    type: z.literal('file-exists'),\r\n    path: z.string(),\r\n  }),\r\n\r\n  z.object({\r\n    type: z.literal('file-contains'),\r\n    path: z.string(),\r\n    pattern: z.string(),\r\n  }),\r\n\r\n  z.object({\r\n    type: z.literal('dependency'),\r\n    name: z.string(),\r\n  }),\r\n\r\n  z.object({\r\n    type: z.literal('env'),\r\n    key: z.string(),\r\n  }),\r\n\r\n  z.object({\r\n    type: z.literal('framework'),\r\n    value: z.string(),\r\n  }),\r\n]);\r\n\r\nconst ConditionSchema: z.ZodType<any> = z.lazy(() =>\r\n  z.union([\r\n    ConditionAtomSchema,\r\n\r\n    z.object({\r\n      all: z.array(ConditionSchema),\r\n    }),\r\n\r\n    z.object({\r\n      any: z.array(ConditionSchema),\r\n    }),\r\n\r\n    z.object({\r\n      not: ConditionSchema,\r\n    }),\r\n  ]),\r\n);\r\n\r\nconst BaseStepSchema = z.object({\r\n  condition: z\r\n    .object({\r\n      if: ConditionSchema.optional(),\r\n      unless: ConditionSchema.optional(),\r\n    })\r\n    .optional(),\r\n});\r\n\r\nexport const SetupStepSchema = z.discriminatedUnion('type', [\r\n  BaseStepSchema.extend({\r\n    type: z.literal('dependencies'),\r\n    packages: z.record(z.string(), z.string()),\r\n  }),\r\n\r\n  // Detect framework\r\n  BaseStepSchema.extend({\r\n    type: z.literal('detect-framework'),\r\n    name: z.string(),\r\n    saveAs: z.string().optional(),\r\n  }),\r\n\r\n  // Detect workdir\r\n  BaseStepSchema.extend({\r\n    type: z.literal('detect-workdir'),\r\n    name: z.string(),\r\n    saveAs: z.string().optional(),\r\n  }),\r\n\r\n  // Context update\r\n  BaseStepSchema.extend({\r\n    type: z.literal('context-update'),\r\n    name: z.string(),\r\n    data: z.record(z.string(), z.any()),\r\n  }),\r\n\r\n  // Assert\r\n  BaseStepSchema.extend({\r\n    type: z.literal('assert'),\r\n    name: z.string(),\r\n\r\n    check: z.discriminatedUnion('type', [\r\n      z.object({\r\n        type: z.literal('dependency'),\r\n        packages: z.array(z.string()),\r\n      }),\r\n\r\n      z.object({\r\n        type: z.literal('file-exists'),\r\n        path: z.string(),\r\n      }),\r\n\r\n      z.object({\r\n        type: z.literal('framework'),\r\n        value: z.array(z.string()),\r\n      }),\r\n\r\n      z.object({\r\n        type: z.literal('env'),\r\n        key: z.string(),\r\n      }),\r\n    ]),\r\n\r\n    onFail: z.object({\r\n      exit: z.boolean().default(true),\r\n      message: z.union([z.string(), z.array(z.string())]),\r\n    }),\r\n  }),\r\n\r\n  // Prompt\r\n  BaseStepSchema.extend({\r\n    type: z.literal('prompt'),\r\n    name: z.string(),\r\n    promptType: z.enum(['text', 'select', 'confirm', 'file-search']),\r\n    message: z.string(),\r\n    saveAs: z.string(), // where to save in config\r\n    default: z.any().optional(),\r\n    // For file-search\r\n    pattern: z.string().optional(),\r\n    exclude: z.array(z.string()).optional(),\r\n    // For select\r\n    options: z\r\n      .array(\r\n        z.object({\r\n          value: z.string(),\r\n          label: z.string(),\r\n        }),\r\n      )\r\n      .optional(),\r\n    // Validation\r\n    validate: z\r\n      .object({\r\n        pattern: z.string().optional(),\r\n        required: z.boolean().optional(),\r\n      })\r\n      .optional(),\r\n  }),\r\n\r\n  // File append\r\n  BaseStepSchema.extend({\r\n    type: z.literal('file-append'),\r\n    target: z.string(), // supports {{variable}}\r\n    content: z.string().optional(),\r\n    contentPath: z.string().optional(), // from registry\r\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\r\n  }),\r\n\r\n  // File create\r\n  BaseStepSchema.extend({\r\n    type: z.literal('file-create'),\r\n    target: z.string(),\r\n    content: z.string().optional(),\r\n    contentPath: z.string().optional(),\r\n    overwrite: z.boolean().optional().default(false),\r\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\r\n  }),\r\n\r\n  // File update\r\n  BaseStepSchema.extend({\r\n    type: z.literal('file-update'),\r\n    target: z.string(),\r\n    search: z.string(), // regex pattern\r\n    replace: z.string(), // replacement string\r\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\r\n  }),\r\n\r\n  // File update JSON\r\n  BaseStepSchema.extend({\r\n    type: z.literal('file-update-json'),\r\n    target: z.string(),\r\n    content: z.record(z.string(), z.any()),\r\n    merge: z.enum(['shallow', 'deep']).optional().default('deep'),\r\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\r\n  }),\r\n]);\r\n\r\nexport const SetupSchema = z.object({\r\n  steps: z.array(SetupStepSchema),\r\n});\r\n\r\nexport type SetupStep = z.infer<typeof SetupStepSchema>;\r\nexport type Setup = z.infer<typeof SetupSchema>;\r\n","import { Setup, SetupSchema } from '../schemas/setup-schema';\r\n\r\nexport async function fetchSetup(registryUrl: string): Promise<Setup> {\r\n  const url = `${registryUrl}/setup.json`;\r\n\r\n  try {\r\n    const response = await fetch(url);\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`${response.statusText}`);\r\n    }\r\n\r\n    const data = await response.json();\r\n\r\n    return SetupSchema.parse(data);\r\n  } catch (error) {\r\n    throw new Error(\r\n      `Failed to fetch setup configuration: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n    );\r\n  }\r\n}\r\n","import fs from 'fs/promises';\r\nimport { existsSync } from 'fs';\r\nimport path from 'path';\r\nimport { glob } from 'glob';\r\nimport { text, select, confirm, log } from '@clack/prompts';\r\nimport { defu } from 'defu';\r\nimport type { Setup, SetupStep } from '../schemas/setup-schema';\r\nimport { detectFramework } from './detect-framework';\r\nimport { installDependencies } from './install-dependencies';\r\nimport { abortIfCancel } from '~/lib/utils';\r\nimport { detectWorkdir } from '~/lib/detect-workdir';\r\nimport picocolors from 'picocolors';\r\n\r\nexport interface SetupContext {\r\n  [key: string]: any;\r\n}\r\n\r\ninterface ExecutorOptions {\r\n  cwd?: string;\r\n}\r\n\r\nconst executable = [\r\n  'prompt',\r\n  'detect-framework',\r\n  'detect-workdir',\r\n  'assert',\r\n  'context-update',\r\n];\r\n\r\nexport async function executeSetup(\r\n  setup: Setup,\r\n  options: ExecutorOptions = {},\r\n): Promise<SetupContext> {\r\n  const context: SetupContext = {};\r\n  const cwd = options.cwd || process.cwd();\r\n\r\n  // Execute steps sequentially, checking condition each time\r\n  for (const step of setup.steps) {\r\n    // Only process setup/context steps (not file operations)\r\n    if (!executable.includes(step.type)) {\r\n      continue; // Skip file operations for phase 2\r\n    }\r\n\r\n    // Check condition with CURRENT context\r\n    if (await shouldRunStep(step, context, cwd)) {\r\n      await executeStep(step, context, cwd);\r\n      // Context is updated here, next step will see the new context!\r\n    }\r\n  }\r\n\r\n  return context;\r\n}\r\n\r\nexport async function executeSetupActions(\r\n  setup: Setup,\r\n  context: SetupContext,\r\n  options: ExecutorOptions = {},\r\n): Promise<void> {\r\n  const cwd = options.cwd || process.cwd();\r\n\r\n  // Execute action steps sequentially\r\n  for (const step of setup.steps) {\r\n    // Skip setup steps (already done)\r\n    if (executable.includes(step.type)) {\r\n      continue;\r\n    }\r\n\r\n    // Evaluate condition with final context\r\n    if (await shouldRunStep(step, context, cwd)) {\r\n      await executeStep(step, context, cwd);\r\n    }\r\n  }\r\n}\r\n\r\nexport async function previewSetupActions(\r\n  setup: Setup,\r\n  context: SetupContext,\r\n  options: ExecutorOptions = {},\r\n): Promise<string[]> {\r\n  const actions: string[] = [];\r\n  const cwd = options.cwd || process.cwd();\r\n\r\n  // Preview action steps only\r\n  for (const step of setup.steps) {\r\n    // Skip setup steps\r\n    if (executable.includes(step.type)) {\r\n      continue;\r\n    }\r\n\r\n    // Check if step will run\r\n    if (!(await shouldRunStep(step, context, cwd))) {\r\n      continue;\r\n    }\r\n\r\n    // Add to preview\r\n    if (step.type === 'dependencies') {\r\n      const count = Object.keys(step.packages).length;\r\n      actions.push(`Install ${count} required package${count > 1 ? 's' : ''}`);\r\n    } else if (step.type === 'file-create') {\r\n      const target = interpolate(step.target, context);\r\n      actions.push(`Create \\`${target}\\``);\r\n    } else if (step.type === 'file-append') {\r\n      const target = interpolate(step.target, context);\r\n      actions.push(`Append to \\`${target}\\``);\r\n    } else if (step.type === 'file-update') {\r\n      const target = interpolate(step.target, context);\r\n      actions.push(`Update \\`${target}\\``);\r\n    } else if (step.type === 'file-update-json') {\r\n      const target = interpolate(step.target, context);\r\n      actions.push(`Update \\`${target}\\``);\r\n    }\r\n  }\r\n\r\n  return actions;\r\n}\r\n\r\nasync function executeStep(\r\n  step: SetupStep,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  switch (step.type) {\r\n    case 'assert':\r\n      await executeAssert(step, context, cwd);\r\n      break;\r\n    case 'dependencies':\r\n      await executeDependencies(step, cwd);\r\n      break;\r\n    case 'detect-framework':\r\n      await executeDetectFramework(step, context, cwd);\r\n      break;\r\n    case 'detect-workdir':\r\n      await executeDetectWorkdir(step, context, cwd);\r\n      break;\r\n    case 'prompt':\r\n      await executePrompt(step, context, cwd);\r\n      break;\r\n    case 'file-append':\r\n      await executeFileAppend(step, context, cwd);\r\n      break;\r\n    case 'file-create':\r\n      await executeFileCreate(step, context, cwd);\r\n      break;\r\n    case 'file-update':\r\n      await executeFileUpdate(step, context, cwd);\r\n      break;\r\n    case 'file-update-json':\r\n      await executeFileUpdateJson(step, context, cwd);\r\n      break;\r\n    case 'context-update':\r\n      await executeContextUpdate(step, context, cwd);\r\n      break;\r\n  }\r\n}\r\n\r\nasync function executeContextUpdate(\r\n  step: Extract<SetupStep, { type: 'context-update' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  for (const [key, value] of Object.entries(step.data)) {\r\n    const interpolatedValue =\r\n      typeof value === 'string' ? interpolate(value, context) : value;\r\n\r\n    setNestedValue(context, key, interpolatedValue);\r\n  }\r\n}\r\n\r\nasync function executeAssert(\r\n  step: Extract<SetupStep, { type: 'assert' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  const ok = await runAssertCheck(step.check, context, cwd);\r\n\r\n  if (!ok) {\r\n    const message = Array.isArray(step.onFail.message)\r\n      ? step.onFail.message.join('\\n')\r\n      : step.onFail.message;\r\n\r\n    if (step.onFail?.exit !== false) {\r\n      throw new Error(message);\r\n    }\r\n\r\n    // console.warn(message);\r\n  }\r\n}\r\n\r\nasync function runAssertCheck(\r\n  check: any,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<boolean> {\r\n  switch (check.type) {\r\n    case 'dependency':\r\n      return checkDependencies(check.packages, cwd);\r\n\r\n    case 'file-exists':\r\n      return existsSync(path.join(cwd, check.path));\r\n\r\n    case 'framework':\r\n      return check.value.includes(context.framework);\r\n\r\n    case 'env':\r\n      return process.env[check.key] !== undefined;\r\n\r\n    default:\r\n      throw new Error(`Unknown assert check type: ${check.type}`);\r\n  }\r\n}\r\n\r\nasync function checkDependencies(\r\n  packages: string[],\r\n  cwd: string,\r\n): Promise<boolean> {\r\n  try {\r\n    const pkgPath = path.join(cwd, 'package.json');\r\n    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));\r\n\r\n    const deps = {\r\n      ...pkg.dependencies,\r\n      ...pkg.devDependencies,\r\n    };\r\n\r\n    return packages.every((name) => deps[name]);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function executeDependencies(\r\n  step: Extract<SetupStep, { type: 'dependencies' }>,\r\n  cwd: string,\r\n): Promise<void> {\r\n  await installDependencies(step.packages, cwd);\r\n}\r\n\r\nasync function executeDetectWorkdir(\r\n  step: Extract<SetupStep, { type: 'detect-workdir' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  const workdir = await detectWorkdir(cwd);\r\n  const saveAs = step.saveAs || step.name;\r\n  setNestedValue(context, saveAs, workdir);\r\n}\r\n\r\nasync function executeDetectFramework(\r\n  step: Extract<SetupStep, { type: 'detect-framework' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  const [framework, frameworkLabel] = await detectFramework(cwd);\r\n\r\n  log.info(\r\n    `Framework: ${picocolors.bgWhiteBright(picocolors.black(` ${frameworkLabel} `))}`,\r\n  );\r\n\r\n  const saveAs = step.saveAs || step.name;\r\n  setNestedValue(context, saveAs, framework);\r\n}\r\n\r\nasync function executePrompt(\r\n  step: Extract<SetupStep, { type: 'prompt' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  let answer: any;\r\n\r\n  if (step.promptType === 'text') {\r\n    const input = await text({\r\n      message: step.message,\r\n      placeholder: step.default as string,\r\n      validate: (value) => {\r\n        const actualValue = value || (step.default as string);\r\n\r\n        if (step.validate?.required && !actualValue) {\r\n          return 'This field is required';\r\n        }\r\n        if (step.validate?.pattern && actualValue) {\r\n          const regex = new RegExp(step.validate.pattern);\r\n          if (!regex.test(actualValue)) {\r\n            return `Must match pattern: ${step.validate.pattern}`;\r\n          }\r\n        }\r\n      },\r\n    });\r\n\r\n    abortIfCancel(input);\r\n\r\n    answer = input || step.default;\r\n  } else if (step.promptType === 'select' && step.options) {\r\n    answer = await select({\r\n      message: step.message,\r\n      options: step.options,\r\n    });\r\n\r\n    abortIfCancel(answer);\r\n  } else if (step.promptType === 'confirm') {\r\n    answer = await confirm({\r\n      message: step.message,\r\n    });\r\n    abortIfCancel(answer);\r\n  } else if (step.promptType === 'file-search') {\r\n    const pattern = step.pattern || '**/*';\r\n    const exclude = step.exclude || ['node_modules', 'dist', '.git'];\r\n\r\n    const files = await glob(pattern, {\r\n      cwd,\r\n      ignore: exclude,\r\n      dot: false,\r\n      absolute: false,\r\n    });\r\n\r\n    if (files.length === 0) {\r\n      answer = await text({\r\n        message: step.message,\r\n        defaultValue: step.default as string,\r\n      });\r\n    } else {\r\n      // Sort & limit results (biar gak overwhelming)\r\n      const sortedFiles = files.sort((a, b) => a.localeCompare(b)).slice(0, 20); // ← max 20 files\r\n\r\n      const options = sortedFiles.map((f) => ({\r\n        value: f,\r\n        label: f,\r\n      }));\r\n\r\n      options.push({\r\n        value: '__custom__',\r\n        label: 'Enter custom path...',\r\n      });\r\n\r\n      const selected = await select({\r\n        message: step.message,\r\n        options,\r\n      });\r\n\r\n      abortIfCancel(selected);\r\n\r\n      if (selected === '__custom__') {\r\n        answer = await text({\r\n          message: 'Enter file path:',\r\n          defaultValue: step.default as string,\r\n        });\r\n\r\n        abortIfCancel(answer);\r\n      } else {\r\n        answer = selected;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (answer !== undefined) {\r\n    setNestedValue(context, step.saveAs || step.name, answer);\r\n  }\r\n}\r\n\r\nasync function executeFileAppend(\r\n  step: Extract<SetupStep, { type: 'file-append' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  const target = interpolate(step.target, context);\r\n  const targetPath = path.join(cwd, target);\r\n\r\n  if (!existsSync(targetPath)) {\r\n    throw new Error(`File not found: ${target}`);\r\n  }\r\n\r\n  const content = step.content || (await getContent(step.contentPath!));\r\n  const existing = await fs.readFile(targetPath, 'utf-8');\r\n\r\n  const newContent = existing + '\\n' + content;\r\n\r\n  await fs.writeFile(targetPath, newContent, 'utf-8');\r\n\r\n  if (step.saveTargetAs) {\r\n    saveTargetAs(context, step.saveTargetAs, target);\r\n  }\r\n}\r\n\r\nasync function executeFileCreate(\r\n  step: Extract<SetupStep, { type: 'file-create' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  const target = interpolate(step.target, context);\r\n  const targetPath = path.join(cwd, target);\r\n\r\n  if (existsSync(targetPath) && !step.overwrite) {\r\n    const shouldOverwrite = await confirm({\r\n      message: `File \\`${target}\\` already exists. Overwrite?`,\r\n      initialValue: false,\r\n    });\r\n\r\n    if (!shouldOverwrite) {\r\n      return;\r\n    }\r\n  }\r\n\r\n  const content = step.content || (await getContent(step.contentPath!));\r\n\r\n  await fs.mkdir(path.dirname(targetPath), { recursive: true });\r\n  await fs.writeFile(targetPath, content, 'utf-8');\r\n\r\n  if (step.saveTargetAs) {\r\n    saveTargetAs(context, step.saveTargetAs, target);\r\n  }\r\n}\r\n\r\nasync function executeFileUpdate(\r\n  step: Extract<SetupStep, { type: 'file-update' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  const target = interpolate(step.target, context);\r\n  const targetPath = path.join(cwd, target);\r\n\r\n  if (!existsSync(targetPath)) {\r\n    throw new Error(`File not found: ${target}`);\r\n  }\r\n\r\n  let content = await fs.readFile(targetPath, 'utf-8');\r\n\r\n  // Apply replacement\r\n  const searchRegex = new RegExp(step.search, 'gms');\r\n\r\n  if (!searchRegex.test(content)) {\r\n    // log.warn(`Pattern not found in ${target}, skipping...`);\r\n    return;\r\n  }\r\n\r\n  const newContent = content.replace(searchRegex, step.replace);\r\n\r\n  await fs.writeFile(targetPath, newContent, 'utf-8');\r\n  log.success(`Updated ${target}`);\r\n\r\n  if (step.saveTargetAs) {\r\n    saveTargetAs(context, step.saveTargetAs, target);\r\n  }\r\n}\r\n\r\nasync function executeFileUpdateJson(\r\n  step: Extract<SetupStep, { type: 'file-update-json' }>,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<void> {\r\n  const target = interpolate(step.target, context);\r\n  const targetPath = path.join(cwd, target);\r\n\r\n  let existing = {};\r\n\r\n  if (existsSync(targetPath)) {\r\n    const content = await fs.readFile(targetPath, 'utf-8');\r\n    existing = JSON.parse(content);\r\n  }\r\n\r\n  const merged =\r\n    step.merge === 'deep'\r\n      ? defu(step.content, existing)\r\n      : { ...existing, ...step.content };\r\n\r\n  await fs.writeFile(targetPath, JSON.stringify(merged, null, 2), 'utf-8');\r\n\r\n  if (step.saveTargetAs) {\r\n    saveTargetAs(context, step.saveTargetAs, target);\r\n  }\r\n}\r\n\r\nfunction interpolate(str: string, context: SetupContext): string {\r\n  return str.replace(/\\{\\{([^}]+)\\}\\}/g, (match, key) => {\r\n    const trimmedKey = key.trim();\r\n\r\n    // Try direct access first\r\n    let value = getNestedValue(context, trimmedKey);\r\n\r\n    // If not found and key doesn't have dots, try inside 'paths'\r\n    if (value === undefined && !trimmedKey.includes('.')) {\r\n      value = getNestedValue(context, `paths.${trimmedKey}`);\r\n    }\r\n\r\n    return value !== undefined ? value : match;\r\n  });\r\n}\r\n\r\nasync function getContent(contentPath: string): Promise<string> {\r\n  const filePath = path.join(process.cwd(), contentPath);\r\n\r\n  try {\r\n    return await fs.readFile(filePath, 'utf-8');\r\n  } catch (error) {\r\n    throw new Error(\r\n      `Failed to read content from ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n    );\r\n  }\r\n}\r\n\r\nfunction getNestedValue(obj: any, path: string): any {\r\n  return path.split('.').reduce((current, key) => current?.[key], obj);\r\n}\r\n\r\nfunction setNestedValue(obj: any, path: string, value: any): void {\r\n  const keys = path.split('.');\r\n  let current = obj;\r\n\r\n  for (let i = 0; i < keys.length - 1; i++) {\r\n    if (!current[keys[i]]) {\r\n      current[keys[i]] = {};\r\n    }\r\n    current = current[keys[i]];\r\n  }\r\n\r\n  current[keys[keys.length - 1]] = value;\r\n}\r\n\r\nasync function evaluateCondition(\r\n  condition: any,\r\n  context: any,\r\n  cwd: string,\r\n): Promise<boolean> {\r\n  // logical operators\r\n  if ('all' in condition) {\r\n    for (const c of condition.all) {\r\n      if (!(await evaluateCondition(c, context, cwd))) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  if ('any' in condition) {\r\n    for (const c of condition.any) {\r\n      if (await evaluateCondition(c, context, cwd)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  if ('not' in condition) {\r\n    return !(await evaluateCondition(condition.not, context, cwd));\r\n  }\r\n\r\n  // atoms\r\n  switch (condition.type) {\r\n    case 'file-exists': {\r\n      return existsSync(path.join(cwd, interpolate(condition.path, context)));\r\n    }\r\n\r\n    case 'file-contains': {\r\n      const fullPath = path.join(cwd, interpolate(condition.path, context));\r\n      if (!existsSync(fullPath)) return false;\r\n\r\n      const content = await fs.readFile(fullPath, 'utf-8');\r\n      const regex = new RegExp(condition.pattern, 'm');\r\n      return regex.test(content);\r\n    }\r\n\r\n    case 'dependency': {\r\n      try {\r\n        const pkg = JSON.parse(\r\n          await fs.readFile(path.join(cwd, 'package.json'), 'utf-8'),\r\n        );\r\n        return (\r\n          pkg.dependencies?.[condition.name] ||\r\n          pkg.devDependencies?.[condition.name]\r\n        );\r\n      } catch {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    case 'env':\r\n      return process.env[condition.key] !== undefined;\r\n\r\n    case 'framework':\r\n      return context.framework === condition.value;\r\n\r\n    default:\r\n      throw new Error(`Unknown condition type: ${condition.type}`);\r\n  }\r\n}\r\n\r\nasync function shouldRunStep(\r\n  step: SetupStep,\r\n  context: SetupContext,\r\n  cwd: string,\r\n): Promise<boolean> {\r\n  if (!step.condition) return true;\r\n\r\n  if (step.condition.if) {\r\n    const ok = await evaluateCondition(step.condition.if, context, cwd);\r\n    if (!ok) return false;\r\n  }\r\n\r\n  if (step.condition.unless) {\r\n    const blocked = await evaluateCondition(\r\n      step.condition.unless,\r\n      context,\r\n      cwd,\r\n    );\r\n    if (blocked) return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nasync function resolveRunnableSteps(\r\n  setup: Setup,\r\n  context: SetupContext,\r\n  cwd: string,\r\n) {\r\n  const result: SetupStep[] = [];\r\n\r\n  for (const step of setup.steps) {\r\n    if (await shouldRunStep(step, context, cwd)) {\r\n      result.push(step);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction saveTargetAs(\r\n  context: SetupContext,\r\n  name: string | string[],\r\n  value: string,\r\n) {\r\n  if (Array.isArray(name)) {\r\n    for (const n of name) {\r\n      setNestedValue(context, n, value);\r\n    }\r\n    return;\r\n  }\r\n\r\n  setNestedValue(context, name, value);\r\n}\r\n","import fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { glob } from 'glob';\r\n\r\nasync function exists(p: string) {\r\n  try {\r\n    await fs.access(p);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function detectFramework(\r\n  cwd: string = process.cwd(),\r\n): Promise<[string, string]> {\r\n  try {\r\n    const pkgPath = path.join(cwd, 'package.json');\r\n    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));\r\n\r\n    const deps = {\r\n      ...pkg.dependencies,\r\n      ...pkg.devDependencies,\r\n    };\r\n\r\n    /* ----------------------------\r\n     * React meta-frameworks\r\n     * ---------------------------- */\r\n\r\n    if (deps['next']) {\r\n      const files = await glob('{pages,src/pages}/_app.{js,ts,jsx,tsx}', {\r\n        cwd,\r\n      });\r\n\r\n      if (files.length > 0) {\r\n        return ['next-pages', 'Next.js Pages'];\r\n      }\r\n      return ['next', 'Next.js'];\r\n    }\r\n\r\n    // React Router v7 (ex-Remix)\r\n    if (deps['react-router'] && deps['@react-router/dev']) {\r\n      return ['react-router', 'React Router v7'];\r\n    }\r\n\r\n    // Remix (legacy but still exists)\r\n    if (deps['@remix-run/react']) return ['remix', 'Remix'];\r\n\r\n    // TanStack Start\r\n    if (deps['@tanstack/react-start'])\r\n      return ['tanstack-start', 'TanStack Start'];\r\n\r\n    // TanStack Router (standalone)\r\n    if (deps['@tanstack/react-router'])\r\n      return ['tanstack-router', 'TanStack Router'];\r\n\r\n    // Astro\r\n    if (deps['astro']) return ['astro', 'Astro'];\r\n\r\n    /* ----------------------------\r\n     * Vite (needs file hint)\r\n     * ---------------------------- */\r\n\r\n    if (\r\n      deps['vite'] &&\r\n      ((await exists(path.join(cwd, 'vite.config.ts'))) ||\r\n        (await exists(path.join(cwd, 'vite.config.js'))))\r\n    ) {\r\n      return ['vite', 'Vite'];\r\n    }\r\n\r\n    /* ----------------------------\r\n     * Laravel (non-Node primary)\r\n     * ---------------------------- */\r\n\r\n    if (\r\n      (await exists(path.join(cwd, 'artisan'))) &&\r\n      (await exists(path.join(cwd, 'composer.json')))\r\n    ) {\r\n      return ['laravel', 'Laravel'];\r\n    }\r\n\r\n    /* ----------------------------\r\n     * Plain React fallback\r\n     * ---------------------------- */\r\n\r\n    if (deps['react']) return ['react', 'React'];\r\n\r\n    return ['unknown', 'Unknown'];\r\n  } catch {\r\n    return ['unknown', 'Unknown'];\r\n  }\r\n}\r\n","import { join } from 'node:path';\r\nimport { existsSync } from 'node:fs';\r\n\r\nexport function detectWorkdir(cwd: string) {\r\n  if (existsSync(join(cwd, 'src'))) {\r\n    return './src/';\r\n  }\r\n\r\n  return './';\r\n}\r\n","import deepmerge from 'deepmerge';\r\nimport fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { Config } from '~/schemas/config-schema';\r\n\r\nexport async function writeConfig(config: Config) {\r\n  // read existing config\r\n  let existingConfig;\r\n  try {\r\n    existingConfig = await fs.readFile(\r\n      path.join(process.cwd(), 'selia.json'),\r\n      'utf-8',\r\n    );\r\n  } catch (error) {\r\n    existingConfig = '{}';\r\n  }\r\n\r\n  // merge configs\r\n  const mergedConfig = deepmerge(JSON.parse(existingConfig), config);\r\n\r\n  const configPath = path.join(process.cwd(), 'selia.json');\r\n  await fs.writeFile(\r\n    configPath,\r\n    JSON.stringify(mergedConfig, null, 2),\r\n    'utf-8',\r\n  );\r\n\r\n  return configPath;\r\n}\r\n","import { Command } from 'commander';\r\nimport { intro, outro, log } from '@clack/prompts';\r\nimport fs from 'fs/promises';\r\nimport picocolors from 'picocolors';\r\nimport { RegistrySchema } from '../schemas/registry-schema';\r\nimport { isRegistryExists } from '~/lib/utils';\r\nimport { cleanBuild } from '~/lib/clean-build';\r\nimport { buildRegistry } from '../lib/build-registry';\r\n\r\nexport const buildCommand = new Command()\r\n  .name('build')\r\n  .description('Build the registry')\r\n  .option('-o, --output <path>', 'Output directory', './public/registry')\r\n  .action(async (options) => {\r\n    intro('Build Registry');\r\n\r\n    try {\r\n      // Check if registry exists\r\n      if (!(await isRegistryExists())) {\r\n        log.error(picocolors.red('Registry file not found: registry.json'));\r\n        process.exit(1);\r\n      }\r\n\r\n      // Read and parse registry\r\n      const registryContent = await fs.readFile('./registry.json', 'utf-8');\r\n      const parsedRegistry = JSON.parse(registryContent);\r\n\r\n      // Validate registry\r\n      const validatedRegistry = RegistrySchema.safeParse(parsedRegistry);\r\n\r\n      if (!validatedRegistry.success) {\r\n        console.log(validatedRegistry.error);\r\n        log.error(picocolors.red('Invalid registry format:'));\r\n        validatedRegistry.error.issues.forEach((err) => {\r\n          log.error(\r\n            picocolors.red(`  - ${err.path.join('.')}: ${err.message}`),\r\n          );\r\n        });\r\n        process.exit(1);\r\n      }\r\n\r\n      // Clean output directory\r\n      await cleanBuild(options.output);\r\n\r\n      // Build registry\r\n      await buildRegistry(validatedRegistry.data, {\r\n        output: options.output,\r\n      });\r\n\r\n      outro(picocolors.green('Registry built successfully! ✓'));\r\n    } catch (error) {\r\n      log.error(\r\n        picocolors.red(\r\n          error instanceof Error ? error.message : 'An unknown error occurred',\r\n        ),\r\n      );\r\n      process.exit(1);\r\n    }\r\n  });\r\n","import { z } from 'zod';\r\nimport { ItemSchema } from './item-schema';\r\nimport { SetupSchema } from '~/schemas/setup-schema';\r\n\r\nexport const RegistrySchema = z.object({\r\n  name: z.string(),\r\n  homepage: z.url().optional(),\r\n  items: z.array(ItemSchema),\r\n  setup: z.union([SetupSchema, z.string()]).optional(),\r\n});\r\n\r\nexport type Registry = z.infer<typeof RegistrySchema>;\r\n","import fs from 'fs/promises';\r\n\r\nexport async function cleanBuild(output: string) {\r\n  await fs.rm(output, { recursive: true, force: true }).catch(() => {});\r\n\r\n  await fs.mkdir(output, { recursive: true }).catch(() => {});\r\n}\r\n","import fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { Registry } from '../schemas/registry-schema';\r\nimport { Item } from '../schemas/item-schema';\r\nimport { log, spinner } from '@clack/prompts';\r\nimport picocolors from 'picocolors';\r\nimport type { Setup } from '../schemas/setup-schema';\r\n\r\ninterface BuildRegistryOptions {\r\n  output: string;\r\n}\r\n\r\nexport async function buildRegistry(\r\n  registry: Registry,\r\n  options: BuildRegistryOptions,\r\n) {\r\n  const s = spinner();\r\n  s.start('Building registry...');\r\n\r\n  try {\r\n    // Build registry.json\r\n    await buildRegistryFile(registry, options.output);\r\n\r\n    // Build individual items\r\n    for (let i = 0; i < registry.items.length; i++) {\r\n      const item = registry.items[i];\r\n      s.message(`Building ${item.name} (${i + 1}/${registry.items.length})`);\r\n      await buildItem(item, options.output);\r\n    }\r\n\r\n    // Build setup if exists\r\n    if (registry.setup) {\r\n      s.message('Building setup configuration...');\r\n      await buildSetup(registry.setup, options.output);\r\n    }\r\n\r\n    s.stop('Build complete');\r\n    log.success(\r\n      picocolors.green(`Built ${registry.items.length} items successfully`),\r\n    );\r\n  } catch (error) {\r\n    s.stop('Build failed');\r\n    const message = error instanceof Error ? error.message : 'Unknown error';\r\n    log.error(picocolors.red(message));\r\n    process.exit(1);\r\n  }\r\n}\r\n\r\nasync function buildRegistryFile(\r\n  registry: Registry,\r\n  output: string,\r\n): Promise<void> {\r\n  // Remove file paths from registry.json (keep metadata only)\r\n  const cleanedItems = registry.items.map((item) => ({\r\n    ...item,\r\n    files: item.files.map(({ path: _, ...file }) => file),\r\n  }));\r\n\r\n  const cleanedRegistry = {\r\n    ...registry,\r\n    items: cleanedItems,\r\n  };\r\n\r\n  if (registry.setup) {\r\n    cleanedRegistry.setup = 'setup.json';\r\n  }\r\n\r\n  await fs.mkdir(output, { recursive: true });\r\n  await fs.writeFile(\r\n    path.join(output, 'registry.json'),\r\n    JSON.stringify(cleanedRegistry, null, 2),\r\n    'utf-8',\r\n  );\r\n}\r\n\r\nasync function buildItem(item: Item, output: string): Promise<void> {\r\n  const filesWithContent = await Promise.all(\r\n    item.files.map(async (file) => {\r\n      if (!file.path) {\r\n        throw new Error(`Path is required for file in item \"${item.name}\"`);\r\n      }\r\n\r\n      const content = await fs.readFile(file.path, 'utf-8');\r\n      const { path: _, ...rest } = file;\r\n\r\n      return {\r\n        ...rest,\r\n        content,\r\n      };\r\n    }),\r\n  );\r\n\r\n  const itemWithContent = {\r\n    ...item,\r\n    files: filesWithContent,\r\n  };\r\n\r\n  await fs.mkdir(output, { recursive: true });\r\n  await fs.writeFile(\r\n    path.join(output, `${item.name}.json`),\r\n    JSON.stringify(itemWithContent, null, 2),\r\n    'utf-8',\r\n  );\r\n}\r\n\r\nasync function buildSetup(setup: Setup, output: string): Promise<void> {\r\n  // Process setup steps and resolve contentPath\r\n  const processedSteps = await Promise.all(\r\n    setup.steps.map(async (step) => {\r\n      // Only process steps with contentPath\r\n      if (\r\n        'contentPath' in step &&\r\n        step.contentPath &&\r\n        (step.type === 'file-append' || step.type === 'file-create')\r\n      ) {\r\n        try {\r\n          const content = await fs.readFile(step.contentPath, 'utf-8');\r\n          const { contentPath: _, ...rest } = step;\r\n\r\n          return {\r\n            ...rest,\r\n            content,\r\n          };\r\n        } catch (error) {\r\n          throw new Error(\r\n            `Failed to read content for setup step from \"${step.contentPath}\": ${\r\n              error instanceof Error ? error.message : 'Unknown error'\r\n            }`,\r\n          );\r\n        }\r\n      }\r\n\r\n      return step;\r\n    }),\r\n  );\r\n\r\n  const processedSetup = {\r\n    steps: processedSteps,\r\n  };\r\n\r\n  await fs.writeFile(\r\n    path.join(output, 'setup.json'),\r\n    JSON.stringify(processedSetup, null, 2),\r\n    'utf-8',\r\n  );\r\n}\r\n\r\nasync function processSetupPaths(setup: Setup): Promise<Setup> {\r\n  const processedSteps = setup.steps.map((step) => {\r\n    if ('contentPath' in step && step.contentPath) {\r\n      const { contentPath: _, content: __, ...rest } = step as any;\r\n      return rest;\r\n    }\r\n\r\n    if ('content' in step && step.content) {\r\n      const { content: _, ...rest } = step as any;\r\n      return rest;\r\n    }\r\n\r\n    return step;\r\n  });\r\n\r\n  return {\r\n    steps: processedSteps,\r\n  };\r\n}\r\n"],"mappings":"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","names":["spinner","log","fs","path","z","z","path","fs","path","fs","path","fs","existsSync","fs","path","log","existsSync","path","spinner","fs","Command","intro","outro","log","spinner","confirm","picocolors","z","fs","existsSync","path","glob","select","log","defu","fs","path","existsSync","picocolors","existsSync","path","fs","log","select","glob","defu","fs","path","Command","intro","picocolors","log","outro","spinner","confirm","Command","intro","outro","log","fs","picocolors","z","z","fs","fs","path","log","spinner","picocolors","Command","intro","log","picocolors","fs","outro"]}