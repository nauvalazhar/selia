{"version":3,"sources":["../src/index.ts","../src/commands/add.ts","../src/lib/load-config.ts","../src/schemas/config-schema.ts","../src/lib/default-config.ts","../src/schemas/item-schema.ts","../src/lib/fetch-item.ts","../src/lib/resolve-dependencies.ts","../src/lib/resolve-import.ts","../src/lib/install-dependencies.ts","../src/lib/package-manager.ts","../src/lib/check-workspace.ts","../src/lib/utils.ts","../src/lib/resolve-registry.ts","../src/commands/init.ts","../src/schemas/setup-schema.ts","../src/lib/fetch-setup.ts","../src/lib/setup-executor.ts","../src/lib/detect-framework.ts","../src/lib/detect-workdir.ts","../src/lib/write-config.ts","../src/commands/build.ts","../src/schemas/registry-schema.ts","../src/lib/clean-build.ts","../src/lib/build-registry.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { program } from 'commander';\nimport { addCommand } from '~/commands/add';\nimport { initCommand } from '~/commands/init';\nimport { buildCommand } from '~/commands/build';\n\nprogram.version('0.0.1');\n\nprogram.addCommand(initCommand);\nprogram.addCommand(addCommand);\nprogram.addCommand(buildCommand);\n\nprogram.parse();\n","// commands/add.ts\nimport { Command } from 'commander';\nimport { intro, outro, spinner, log, select } from '@clack/prompts';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { loadConfig } from '~/lib/load-config';\nimport { fetchItems } from '~/lib/fetch-item';\nimport { resolveDependencies } from '~/lib/resolve-dependencies';\nimport { resolveImportAlias, resolveTargetPath } from '~/lib/resolve-import';\nimport { installDependencies } from '~/lib/install-dependencies';\nimport { abortIfCancel } from '~/lib/utils';\nimport picocolors from 'picocolors';\n\nimport { existsSync } from 'fs';\nimport { resolveRegistry } from '~/lib/resolve-registry';\n\nexport const addCommand = new Command()\n  .name('add')\n  .description('Add components to your project')\n  .argument('[items...]', 'Items to add')\n  .option('-y, --yes', 'Skip confirmation prompts')\n  .option('--no-install', 'Skip installing dependencies')\n  .option('--overwrite', 'Overwrite existing files without asking')\n  .action(async (itemNames: string[], options) => {\n    console.log();\n    intro(picocolors.bgBlue(picocolors.blackBright(' Add Item ')));\n\n    log.warn(\n      picocolors.yellow(\n        'The CLI is still experimental, report any issues on GitHub!',\n      ),\n    );\n\n    if (itemNames.length === 0) {\n      log.info('You must provide at least one item.');\n      log.info(\n        `Run ${picocolors.cyan('selia add <items>')} to add items to your project.`,\n      );\n      console.log();\n      return;\n    }\n\n    // check config file\n    if (!existsSync(path.join(process.cwd(), 'selia.json'))) {\n      log.error(\n        picocolors.red('You can only use this command in a Selia project.'),\n      );\n      console.log();\n      return;\n    }\n\n    try {\n      const config = await loadConfig();\n      const s = spinner();\n      const { runtimeUrl: registryUrl } = await resolveRegistry(process.cwd());\n\n      if (!registryUrl) {\n        log.error(picocolors.red('Registry not found'));\n        return;\n      }\n\n      //   s.start(`Fetching ${itemNames.length} item(s) from registry...`);\n      const items = await fetchItems(registryUrl, itemNames);\n      //   s.stop(`Fetched ${items.length} item(s)`);\n\n      s.start('Resolving dependencies...');\n      const resolved = await resolveDependencies(items, registryUrl);\n      const npmPackagesCount = Object.keys(resolved.npmPackages).length;\n      s.stop(\n        `Resolved ${resolved.items.size} item(s) and ${npmPackagesCount} npm package(s)`,\n      );\n\n      const allItems = Array.from(resolved.items.values());\n      const npmPackages = resolved.npmPackages;\n\n      // Check for existing files\n      const existingFiles: string[] = [];\n      const filesToWrite: Array<{\n        item: (typeof allItems)[0];\n        file: (typeof allItems)[0]['files'][0];\n        targetPath: string;\n        content: string;\n      }> = [];\n\n      for (const item of allItems) {\n        for (const file of item.files) {\n          const basePath = resolveTargetPath(\n            file.target,\n            config,\n            process.cwd(),\n          );\n          const targetPath = path.join(basePath, file.name);\n\n          let content = file.content || '';\n          content = resolveImportAlias(content, config);\n\n          filesToWrite.push({ item, file, targetPath, content });\n\n          if (existsSync(targetPath)) {\n            existingFiles.push(path.relative(process.cwd(), targetPath));\n          }\n        }\n      }\n\n      // Handle existing files\n      if (existingFiles.length > 0 && !options.overwrite) {\n        log.warn(`Found ${existingFiles.length} existing file(s):`);\n        existingFiles.forEach((f) =>\n          console.log(`  ${picocolors.yellow('•')} ${f}`),\n        );\n        console.log();\n\n        const overwriteChoice = await select({\n          message: 'How do you want to proceed?',\n          initialValue: 'skip',\n          options: [\n            { value: 'overwrite', label: 'Overwrite all existing files' },\n            { value: 'skip', label: 'Skip existing files' },\n            { value: 'cancel', label: 'Cancel operation' },\n          ],\n        });\n\n        abortIfCancel(overwriteChoice);\n\n        if (overwriteChoice === 'cancel') {\n          outro('Cancelled');\n          process.exit(0);\n        }\n\n        if (overwriteChoice === 'skip') {\n          // Filter out existing files\n          const skippedCount = filesToWrite.length;\n          filesToWrite.splice(\n            0,\n            filesToWrite.length,\n            ...filesToWrite.filter((f) => !existsSync(f.targetPath)),\n          );\n          log.info(\n            `Skipping ${skippedCount - filesToWrite.length} existing file(s)`,\n          );\n        }\n      }\n\n      // Write files\n      if (filesToWrite.length === 0) {\n        log.warn('No files to write');\n        outro('Done!');\n        return;\n      }\n\n      s.start('Writing files...');\n      let filesWritten = 0;\n      const writtenFileNames = new Set<{ name: string; targetPath: string }>();\n      for (const { targetPath, content, item } of filesToWrite) {\n        await fs.mkdir(path.dirname(targetPath), { recursive: true });\n        await fs.writeFile(targetPath, content, 'utf-8');\n        filesWritten++;\n        // Collect unique item names that are being written\n        writtenFileNames.add({ name: item.name, targetPath });\n      }\n\n      s.stop(`Wrote ${filesWritten} file(s):`);\n\n      if (writtenFileNames.size > 0) {\n        log.message(\n          Array.from(writtenFileNames)\n            .map(\n              ({ name, targetPath }) =>\n                `${picocolors.green('•')} ${path.relative(process.cwd(), targetPath)}`,\n            )\n            .join('\\n'),\n        );\n      }\n\n      // Install npm dependencies\n      if (options.install && Object.keys(npmPackages).length > 0) {\n        await installDependencies(npmPackages);\n      }\n\n      outro('Items added successfully! ✓');\n    } catch (error) {\n      log.error(\n        picocolors.red(\n          error instanceof Error ? error.message : 'An unknown error occurred',\n        ),\n      );\n      console.log();\n      process.exit(1);\n    }\n  });\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { ConfigSchema, type Config } from '../schemas/config-schema';\nimport { defaultConfig } from '~/lib/default-config';\nimport defu from 'defu';\nimport { log } from '@clack/prompts';\nimport z from 'zod';\n\nexport async function loadConfig(cwd: string = process.cwd()): Promise<Config> {\n  const configPath = path.join(cwd, 'selia.json');\n\n  try {\n    const content = await fs.readFile(configPath, 'utf-8');\n    const data = JSON.parse(content);\n\n    const merged = defu(data, defaultConfig);\n\n    const config = ConfigSchema.parse(merged);\n\n    log.info(`Loaded config from ${path.relative(cwd, configPath)}`);\n\n    return config;\n  } catch (error) {\n    if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {\n      log.warn(\n        `No config file found at ${path.relative(cwd, configPath)} (using default config)`,\n      );\n\n      return defaultConfig;\n    }\n\n    if (error instanceof SyntaxError) {\n      throw new Error(\n        `Invalid JSON in config file ${configPath}: ${error.message}`,\n      );\n    }\n\n    if (error instanceof z.ZodError) {\n      throw new Error(\n        `Invalid config format:\\n${error.issues.map((e) => `  - ${e.path.join('.')}: ${e.message}`).join('\\n')}`,\n      );\n    }\n\n    throw new Error(\n      `Failed to load config from ${configPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n","import { z } from 'zod';\n\nexport const ConfigSchema = z.object({\n  framework: z.string().optional(),\n  paths: z.record(z.string(), z.string()),\n  imports: z.record(z.string(), z.string()),\n  registries: z\n    .object({\n      default: z.string().optional(),\n      sources: z\n        .record(\n          z.string(),\n          z.object({\n            name: z.string(),\n            url: z.url(),\n            homepage: z.url().optional(),\n          }),\n        )\n        .optional(),\n    })\n    .optional(),\n});\n\nexport type Config = z.infer<typeof ConfigSchema>;\n","import { Config } from '../schemas/config-schema';\n\nexport const defaultConfig = {\n  framework: 'react',\n  paths: {\n    components: 'components/selia',\n    utils: 'lib/utils.ts',\n  },\n  imports: {\n    utils: '@/lib/utils',\n    components: '@/components/selia',\n  },\n} satisfies Config;\n","import { z } from 'zod';\n\nexport const ItemSchema = z.object({\n  name: z.string(),\n  type: z.union([\n    z.enum(['component', 'block', 'hook', 'util', 'config']),\n    z.string(),\n  ]),\n  dependencies: z\n    .object({\n      npm: z.record(z.string(), z.string()).optional(),\n      items: z.array(z.string()).optional(),\n    })\n    .optional(),\n  files: z.array(\n    z.object({\n      name: z.string(),\n      content: z.string().optional(),\n      target: z.string(),\n      path: z.string().optional(),\n      type: z\n        .union([\n          z.enum(['component', 'block', 'hook', 'util', 'config']),\n          z.string(),\n        ])\n        .optional(),\n    }),\n  ),\n});\n\nexport type Item = z.infer<typeof ItemSchema>;\n","import { Item, ItemSchema } from '../schemas/item-schema';\n\nexport async function fetchItem(\n  registryUrl: string,\n  itemName: string,\n): Promise<Item> {\n  const url = `${registryUrl}/${itemName}.json`;\n\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        throw new Error(`No item found.`);\n      }\n\n      throw new Error(\n        `Failed to fetch item \"${itemName}\" from registry: ${response.statusText}`,\n      );\n    }\n\n    const data = await response.json();\n    return ItemSchema.parse(data);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error('Item could not be found.');\n    }\n\n    throw new Error('Failed to fetch item.');\n  }\n}\n\nexport async function fetchItems(\n  registryUrl: string,\n  itemNames: string[],\n): Promise<Item[]> {\n  const items = await Promise.all(\n    itemNames.map((name) => fetchItem(registryUrl, name)),\n  );\n  return items;\n}\n","import { Item } from '../schemas/item-schema';\nimport { fetchItem } from './fetch-item';\n\ninterface ResolvedDependencies {\n  items: Map<string, Item>; // name -> item\n  npmPackages: Record<string, string>; // package -> version\n}\n\nexport async function resolveDependencies(\n  items: Item[],\n  registryUrl: string,\n  visited: Set<string> = new Set(),\n): Promise<ResolvedDependencies> {\n  const result: ResolvedDependencies = {\n    items: new Map(),\n    npmPackages: {},\n  };\n\n  for (const item of items) {\n    // Skip if already processed\n    if (visited.has(item.name)) continue;\n    visited.add(item.name);\n\n    // Add current item\n    result.items.set(item.name, item);\n\n    // Collect npm dependencies\n    if (item.dependencies?.npm) {\n      Object.assign(result.npmPackages, item.dependencies.npm);\n    }\n\n    // Recursively fetch item dependencies\n    if (item.dependencies?.items && item.dependencies.items.length > 0) {\n      const depItems = await Promise.all(\n        item.dependencies.items.map((depName) =>\n          fetchItem(registryUrl, depName),\n        ),\n      );\n\n      const depResolved = await resolveDependencies(\n        depItems,\n        registryUrl,\n        visited,\n      );\n\n      // Merge results\n      for (const [name, depItem] of depResolved.items) {\n        result.items.set(name, depItem);\n      }\n      Object.assign(result.npmPackages, depResolved.npmPackages);\n    }\n  }\n\n  return result;\n}\n","import { Config } from '../schemas/config-schema';\nimport path from 'path';\n\nexport function resolveImportAlias(content: string, config: Config): string {\n  let resolved = content;\n\n  const regex = /\\bfrom\\s+(['\"`])(#(\\w+)(?:\\/[^'\"`]*)?)\\1/g;\n\n  resolved = resolved.replace(regex, (match, quote, fullPath, key) => {\n    const target = config.imports[key];\n\n    if (!target) {\n      return match;\n    }\n\n    const replaced = fullPath.replace(`#${key}`, target);\n    return `from ${quote}${replaced}${quote}`;\n  });\n\n  return resolved;\n}\n\nexport function resolveTargetPath(\n  target: string,\n  config: Config,\n  cwd: string = process.cwd(),\n): string {\n  const configPath = config.paths[target as keyof typeof config.paths];\n\n  if (!configPath) {\n    throw new Error(\n      `Unknown target \"${target}\". Available targets: ${Object.keys(config.paths).join(', ')}`,\n    );\n  }\n\n  return path.join(cwd, configPath);\n}\n","import { execa } from 'execa';\nimport { detectPackageManager, getInstallCommand } from './package-manager';\nimport { spinner } from '@clack/prompts';\nimport {\n  isPnpmWorkspaceRoot,\n  isSinglePackageWorkspace,\n} from '~/lib/check-workspace';\n\nexport async function installDependencies(\n  packages: Record<string, string>,\n  cwd: string = process.cwd(),\n): Promise<void> {\n  if (Object.keys(packages).length === 0) return;\n\n  const pm = await detectPackageManager(cwd);\n  const packagesString = Object.entries(packages)\n    .map(([pkg, version]) => `${pkg}@${version}`)\n    .join(' ');\n\n  const s = spinner();\n  s.start(`Installing dependencies with ${pm}...`);\n\n  try {\n    const [command, ...args] = getInstallCommand(pm).split(' ');\n\n    if (pm === 'pnpm' && (await isPnpmWorkspaceRoot(cwd))) {\n      if (!(await isSinglePackageWorkspace(cwd))) {\n        throw new Error('You need to install dependencies manually.');\n      }\n\n      args.push('-w');\n    }\n\n    await execa(command, [...args, ...packagesString.split(' ')], {\n      cwd,\n      args,\n      stdio: 'pipe',\n    });\n\n    s.stop('Dependencies installed');\n  } catch (error) {\n    s.stop('Failed to install dependencies');\n    throw new Error(\n      `${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n","// utils/package-manager.ts\nimport fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\n\nexport type PackageManager = 'npm' | 'yarn' | 'pnpm' | 'bun';\n\nexport async function detectPackageManager(\n  cwd: string = process.cwd(),\n): Promise<PackageManager> {\n  if (existsSync(path.join(cwd, 'bun.lock'))) return 'bun';\n  if (existsSync(path.join(cwd, 'pnpm-lock.yaml'))) return 'pnpm';\n  if (existsSync(path.join(cwd, 'yarn.lock'))) return 'yarn';\n  if (existsSync(path.join(cwd, 'package-lock.json'))) return 'npm';\n\n  try {\n    const pkgPath = path.join(cwd, 'package.json');\n    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));\n\n    if (pkg.packageManager) {\n      if (pkg.packageManager.startsWith('bun')) return 'bun';\n      if (pkg.packageManager.startsWith('pnpm')) return 'pnpm';\n      if (pkg.packageManager.startsWith('yarn')) return 'yarn';\n    }\n  } catch {}\n\n  // Default to npm\n  return 'npm';\n}\n\nexport function getInstallCommand(pm: PackageManager): string {\n  const commands = {\n    npm: 'npm install',\n    yarn: 'yarn add',\n    pnpm: 'pnpm add',\n    bun: 'bun add',\n  };\n  return commands[pm];\n}\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { parse } from 'yaml';\n\nexport async function isSinglePackageWorkspace(cwd: string) {\n  try {\n    const wsPath = path.join(cwd, 'pnpm-workspace.yaml');\n    const raw = await fs.readFile(wsPath, 'utf-8');\n    const ws = parse(raw);\n\n    const packages = ws?.packages ?? [];\n\n    return (\n      packages.length === 1 && (packages[0] === '.' || packages[0] === './')\n    );\n  } catch {\n    return false;\n  }\n}\n\nexport async function isPnpmWorkspaceRoot(cwd: string): Promise<boolean> {\n  try {\n    await fs.access(path.join(cwd, 'pnpm-workspace.yaml'));\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import fs from 'fs/promises';\nimport { Config } from '../schemas/config-schema';\nimport { cancel, isCancel } from '@clack/prompts';\n\nexport async function isRegistryExists() {\n  try {\n    await fs.access('./registry.json');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport function getRegistryFromConfig(config: Config) {\n  if (!config.registries?.default || !config.registries.sources) {\n    return null;\n  }\n\n  const registry = config.registries.sources[config.registries.default];\n\n  if (!registry) {\n    return null;\n  }\n\n  return registry;\n}\n\nexport function abortIfCancel(value: unknown): never | void {\n  if (isCancel(value)) {\n    cancel('Setup aborted by user.');\n    process.exit(1);\n  }\n}\n","import fs from 'fs/promises';\nimport path from 'path';\n\nexport interface ResolveRegistryResult {\n  runtimeUrl: string;\n  persist: boolean;\n  existingConfig: any | null;\n}\n\nexport async function resolveRegistry(\n  cwd: string,\n  cliRegistry?: string,\n): Promise<ResolveRegistryResult> {\n  const configPath = path.join(cwd, 'selia.json');\n\n  let existingConfig: any = null;\n  try {\n    existingConfig = JSON.parse(await fs.readFile(configPath, 'utf-8'));\n  } catch {}\n\n  const isDev =\n    process.env.SELIA_DEV === '1' || process.env.NODE_ENV === 'development';\n\n  const defaultRegistry = isDev\n    ? 'http://localhost:5173/registry'\n    : 'https://selia.nauv.al/registry';\n\n  const runtimeUrl =\n    cliRegistry ||\n    existingConfig?.registries?.sources?.selia?.url ||\n    defaultRegistry;\n\n  const persist =\n    Boolean(cliRegistry) && !existingConfig?.registries?.sources?.selia;\n\n  return {\n    runtimeUrl,\n    persist,\n    existingConfig,\n  };\n}\n","import { Command } from 'commander';\nimport { intro, outro, log, spinner, note, confirm } from '@clack/prompts';\nimport picocolors from 'picocolors';\nimport { fetchSetup } from '~/lib/fetch-setup';\nimport {\n  executeSetup,\n  executeSetupActions,\n  previewSetupActions,\n} from '~/lib/setup-executor';\nimport { defaultConfig } from '~/lib/default-config';\nimport { resolveRegistry } from '~/lib/resolve-registry';\nimport { writeConfig } from '~/lib/write-config';\nimport { Config } from '~/schemas/config-schema';\nimport { abortIfCancel } from '~/lib/utils';\n\nexport const initCommand = new Command()\n  .name('init')\n  .description('Initialize Selia in your project')\n  .option('-r, --registry <url>', 'Registry URL')\n  .option('-y, --yes', 'Skip confirmation')\n  .action(async (options) => {\n    console.log();\n    intro(picocolors.bgBlue(picocolors.blackBright(' Initialize Selia ')));\n\n    log.warn(\n      picocolors.yellow(\n        'The CLI is still experimental, report any issues on GitHub!',\n      ),\n    );\n\n    if (options.registry) {\n      log.info(\n        'This feature is not available yet.\\nUse default Selia registry instead.',\n      );\n      console.log();\n      return;\n    }\n\n    try {\n      const { runtimeUrl } = await resolveRegistry(\n        process.cwd(),\n        options.registry,\n      );\n\n      const registryUrl = runtimeUrl;\n      if (!registryUrl) {\n        outro('Cancelled.');\n        return;\n      }\n\n      const s = spinner();\n\n      // Try to fetch setup.json\n      let setup;\n      try {\n        s.start('Fetching setup configuration...');\n        setup = await fetchSetup(registryUrl as string);\n        s.stop('Setup configuration loaded');\n      } catch (error) {\n        if (error instanceof Error) {\n          s.stop(error.message);\n          return;\n        }\n\n        s.stop('No setup configuration found');\n\n        const finalConfig = {\n          ...defaultConfig,\n        } as Config;\n\n        await writeConfig(finalConfig);\n\n        outro(picocolors.green('Config created ✓'));\n        log.info(\n          'Run ' +\n            picocolors.cyan('selia add <items>') +\n            ' to add items to your project.',\n        );\n        console.log();\n        return;\n      }\n\n      // Execute setup prompts (Phase 1: Collect info)\n      const context = await executeSetup(setup);\n\n      // Preview actions\n      const actions = await previewSetupActions(setup, context);\n\n      // Always add config creation action\n      actions.unshift('Create `selia.json`');\n\n      // Show what will be done\n      log.info('I will now perform the following actions:');\n      actions.forEach((action) => {\n        console.log(picocolors.dim('  • ') + action);\n      });\n\n      // Confirm\n      if (!options.yes) {\n        const shouldContinue = await confirm({\n          message: 'Is this okay?',\n          initialValue: true,\n        });\n\n        abortIfCancel(shouldContinue);\n\n        if (!shouldContinue) {\n          outro('Cancelled. Nothing was done.');\n          process.exit(0);\n        }\n      }\n\n      // Execute actions (Phase 2: Do the work)\n      await executeSetupActions(setup, context);\n\n      // Build final config\n      const config = context as Config;\n\n      // Write config file\n      s.start('Creating config file...');\n      await writeConfig(config);\n      s.stop('Config file created');\n\n      // Show summary\n      note(picocolors.dim('Config saved to: ') + picocolors.cyan('selia.json'));\n\n      log.info(picocolors.green('Selia initialized successfully! ✓'));\n      outro(\n        'Run ' +\n          picocolors.cyan('selia add <items>') +\n          ' to add items to your project.',\n      );\n      console.log();\n    } catch (error) {\n      log.error(\n        error instanceof Error ? error.message : 'An unknown error occurred',\n      );\n      console.log();\n      process.exit(1);\n    }\n  });\n","import { z } from 'zod';\n\nconst ConditionAtomSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('file-exists'),\n    path: z.string(),\n  }),\n\n  z.object({\n    type: z.literal('file-contains'),\n    path: z.string(),\n    pattern: z.string(),\n  }),\n\n  z.object({\n    type: z.literal('dependency'),\n    name: z.string(),\n  }),\n\n  z.object({\n    type: z.literal('env'),\n    key: z.string(),\n  }),\n\n  z.object({\n    type: z.literal('framework'),\n    value: z.string(),\n  }),\n]);\n\nconst ConditionSchema: z.ZodType<any> = z.lazy(() =>\n  z.union([\n    ConditionAtomSchema,\n\n    z.object({\n      all: z.array(ConditionSchema),\n    }),\n\n    z.object({\n      any: z.array(ConditionSchema),\n    }),\n\n    z.object({\n      not: ConditionSchema,\n    }),\n  ]),\n);\n\nconst BaseStepSchema = z.object({\n  condition: z\n    .object({\n      if: ConditionSchema.optional(),\n      unless: ConditionSchema.optional(),\n    })\n    .optional(),\n});\n\nexport const SetupStepSchema = z.discriminatedUnion('type', [\n  BaseStepSchema.extend({\n    type: z.literal('dependencies'),\n    packages: z.record(z.string(), z.string()),\n  }),\n\n  // Detect framework\n  BaseStepSchema.extend({\n    type: z.literal('detect-framework'),\n    name: z.string(),\n    saveAs: z.string().optional(),\n  }),\n\n  // Detect workdir\n  BaseStepSchema.extend({\n    type: z.literal('detect-workdir'),\n    name: z.string(),\n    saveAs: z.string().optional(),\n  }),\n\n  // Context update\n  BaseStepSchema.extend({\n    type: z.literal('context-update'),\n    name: z.string(),\n    data: z.record(z.string(), z.any()),\n  }),\n\n  // Assert\n  BaseStepSchema.extend({\n    type: z.literal('assert'),\n    name: z.string(),\n\n    check: z.discriminatedUnion('type', [\n      z.object({\n        type: z.literal('dependency'),\n        packages: z.array(z.string()),\n      }),\n\n      z.object({\n        type: z.literal('file-exists'),\n        path: z.string(),\n      }),\n\n      z.object({\n        type: z.literal('framework'),\n        value: z.array(z.string()),\n      }),\n\n      z.object({\n        type: z.literal('env'),\n        key: z.string(),\n      }),\n    ]),\n\n    onFail: z.object({\n      exit: z.boolean().default(true),\n      message: z.union([z.string(), z.array(z.string())]),\n    }),\n  }),\n\n  // Prompt\n  BaseStepSchema.extend({\n    type: z.literal('prompt'),\n    name: z.string(),\n    promptType: z.enum(['text', 'select', 'confirm', 'file-search']),\n    message: z.string(),\n    saveAs: z.string(), // where to save in config\n    default: z.any().optional(),\n    // For file-search\n    pattern: z.string().optional(),\n    exclude: z.array(z.string()).optional(),\n    // For select\n    options: z\n      .array(\n        z.object({\n          value: z.string(),\n          label: z.string(),\n        }),\n      )\n      .optional(),\n    // Validation\n    validate: z\n      .object({\n        pattern: z.string().optional(),\n        required: z.boolean().optional(),\n      })\n      .optional(),\n  }),\n\n  // File append\n  BaseStepSchema.extend({\n    type: z.literal('file-append'),\n    target: z.string(), // supports {{variable}}\n    content: z.string().optional(),\n    contentPath: z.string().optional(), // from registry\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\n  }),\n\n  // File create\n  BaseStepSchema.extend({\n    type: z.literal('file-create'),\n    target: z.string(),\n    content: z.string().optional(),\n    contentPath: z.string().optional(),\n    overwrite: z.boolean().optional().default(false),\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\n  }),\n\n  // File update\n  BaseStepSchema.extend({\n    type: z.literal('file-update'),\n    target: z.string(),\n    search: z.string(), // regex pattern\n    replace: z.string(), // replacement string\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\n  }),\n\n  // File update JSON\n  BaseStepSchema.extend({\n    type: z.literal('file-update-json'),\n    target: z.string(),\n    content: z.record(z.string(), z.any()),\n    merge: z.enum(['shallow', 'deep']).optional().default('deep'),\n    saveTargetAs: z.union([z.string(), z.array(z.string())]).optional(),\n  }),\n]);\n\nexport const SetupSchema = z.object({\n  steps: z.array(SetupStepSchema),\n});\n\nexport type SetupStep = z.infer<typeof SetupStepSchema>;\nexport type Setup = z.infer<typeof SetupSchema>;\n","import { Setup, SetupSchema } from '../schemas/setup-schema';\n\nexport async function fetchSetup(registryUrl: string): Promise<Setup> {\n  const url = `${registryUrl}/setup.json`;\n\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(`${response.statusText}`);\n    }\n\n    const data = await response.json();\n\n    return SetupSchema.parse(data);\n  } catch (error) {\n    throw new Error(\n      `Failed to fetch setup configuration: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n","import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport { glob } from 'glob';\nimport { text, select, confirm, log } from '@clack/prompts';\nimport { defu } from 'defu';\nimport type { Setup, SetupStep } from '../schemas/setup-schema';\nimport { detectFramework } from './detect-framework';\nimport { installDependencies } from './install-dependencies';\nimport { abortIfCancel } from '~/lib/utils';\nimport { detectWorkdir } from '~/lib/detect-workdir';\nimport picocolors from 'picocolors';\n\nexport interface SetupContext {\n  [key: string]: any;\n}\n\ninterface ExecutorOptions {\n  cwd?: string;\n}\n\nconst executable = [\n  'prompt',\n  'detect-framework',\n  'detect-workdir',\n  'assert',\n  'context-update',\n];\n\nexport async function executeSetup(\n  setup: Setup,\n  options: ExecutorOptions = {},\n): Promise<SetupContext> {\n  const context: SetupContext = {};\n  const cwd = options.cwd || process.cwd();\n\n  // Execute steps sequentially, checking condition each time\n  for (const step of setup.steps) {\n    // Only process setup/context steps (not file operations)\n    if (!executable.includes(step.type)) {\n      continue; // Skip file operations for phase 2\n    }\n\n    // Check condition with CURRENT context\n    if (await shouldRunStep(step, context, cwd)) {\n      await executeStep(step, context, cwd);\n      // Context is updated here, next step will see the new context!\n    }\n  }\n\n  return context;\n}\n\nexport async function executeSetupActions(\n  setup: Setup,\n  context: SetupContext,\n  options: ExecutorOptions = {},\n): Promise<void> {\n  const cwd = options.cwd || process.cwd();\n\n  // Execute action steps sequentially\n  for (const step of setup.steps) {\n    // Skip setup steps (already done)\n    if (executable.includes(step.type)) {\n      continue;\n    }\n\n    // Evaluate condition with final context\n    if (await shouldRunStep(step, context, cwd)) {\n      await executeStep(step, context, cwd);\n    }\n  }\n}\n\nexport async function previewSetupActions(\n  setup: Setup,\n  context: SetupContext,\n  options: ExecutorOptions = {},\n): Promise<string[]> {\n  const actions: string[] = [];\n  const cwd = options.cwd || process.cwd();\n\n  // Preview action steps only\n  for (const step of setup.steps) {\n    // Skip setup steps\n    if (executable.includes(step.type)) {\n      continue;\n    }\n\n    // Check if step will run\n    if (!(await shouldRunStep(step, context, cwd))) {\n      continue;\n    }\n\n    // Add to preview\n    if (step.type === 'dependencies') {\n      const count = Object.keys(step.packages).length;\n      actions.push(`Install ${count} required package${count > 1 ? 's' : ''}`);\n    } else if (step.type === 'file-create') {\n      const target = interpolate(step.target, context);\n      actions.push(`Create \\`${target}\\``);\n    } else if (step.type === 'file-append') {\n      const target = interpolate(step.target, context);\n      actions.push(`Append to \\`${target}\\``);\n    } else if (step.type === 'file-update') {\n      const target = interpolate(step.target, context);\n      actions.push(`Update \\`${target}\\``);\n    } else if (step.type === 'file-update-json') {\n      const target = interpolate(step.target, context);\n      actions.push(`Update \\`${target}\\``);\n    }\n  }\n\n  return actions;\n}\n\nasync function executeStep(\n  step: SetupStep,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  switch (step.type) {\n    case 'assert':\n      await executeAssert(step, context, cwd);\n      break;\n    case 'dependencies':\n      await executeDependencies(step, cwd);\n      break;\n    case 'detect-framework':\n      await executeDetectFramework(step, context, cwd);\n      break;\n    case 'detect-workdir':\n      await executeDetectWorkdir(step, context, cwd);\n      break;\n    case 'prompt':\n      await executePrompt(step, context, cwd);\n      break;\n    case 'file-append':\n      await executeFileAppend(step, context, cwd);\n      break;\n    case 'file-create':\n      await executeFileCreate(step, context, cwd);\n      break;\n    case 'file-update':\n      await executeFileUpdate(step, context, cwd);\n      break;\n    case 'file-update-json':\n      await executeFileUpdateJson(step, context, cwd);\n      break;\n    case 'context-update':\n      await executeContextUpdate(step, context, cwd);\n      break;\n  }\n}\n\nasync function executeContextUpdate(\n  step: Extract<SetupStep, { type: 'context-update' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  for (const [key, value] of Object.entries(step.data)) {\n    const interpolatedValue =\n      typeof value === 'string' ? interpolate(value, context) : value;\n\n    setNestedValue(context, key, interpolatedValue);\n  }\n}\n\nasync function executeAssert(\n  step: Extract<SetupStep, { type: 'assert' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const ok = await runAssertCheck(step.check, context, cwd);\n\n  if (!ok) {\n    const message = Array.isArray(step.onFail.message)\n      ? step.onFail.message.join('\\n')\n      : step.onFail.message;\n\n    if (step.onFail?.exit !== false) {\n      throw new Error(message);\n    }\n\n    // console.warn(message);\n  }\n}\n\nasync function runAssertCheck(\n  check: any,\n  context: SetupContext,\n  cwd: string,\n): Promise<boolean> {\n  switch (check.type) {\n    case 'dependency':\n      return checkDependencies(check.packages, cwd);\n\n    case 'file-exists':\n      return existsSync(path.join(cwd, check.path));\n\n    case 'framework':\n      return check.value.includes(context.framework);\n\n    case 'env':\n      return process.env[check.key] !== undefined;\n\n    default:\n      throw new Error(`Unknown assert check type: ${check.type}`);\n  }\n}\n\nasync function checkDependencies(\n  packages: string[],\n  cwd: string,\n): Promise<boolean> {\n  try {\n    const pkgPath = path.join(cwd, 'package.json');\n    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));\n\n    const deps = {\n      ...pkg.dependencies,\n      ...pkg.devDependencies,\n    };\n\n    return packages.every((name) => deps[name]);\n  } catch {\n    return false;\n  }\n}\n\nasync function executeDependencies(\n  step: Extract<SetupStep, { type: 'dependencies' }>,\n  cwd: string,\n): Promise<void> {\n  await installDependencies(step.packages, cwd);\n}\n\nasync function executeDetectWorkdir(\n  step: Extract<SetupStep, { type: 'detect-workdir' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const workdir = await detectWorkdir(cwd);\n  const saveAs = step.saveAs || step.name;\n  setNestedValue(context, saveAs, workdir);\n}\n\nasync function executeDetectFramework(\n  step: Extract<SetupStep, { type: 'detect-framework' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const [framework, frameworkLabel] = await detectFramework(cwd);\n\n  log.info(\n    `Framework: ${picocolors.bgWhiteBright(picocolors.black(` ${frameworkLabel} `))}`,\n  );\n\n  const saveAs = step.saveAs || step.name;\n  setNestedValue(context, saveAs, framework);\n}\n\nasync function executePrompt(\n  step: Extract<SetupStep, { type: 'prompt' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  let answer: any;\n\n  if (step.promptType === 'text') {\n    const input = await text({\n      message: step.message,\n      placeholder: step.default as string,\n      validate: (value) => {\n        const actualValue = value || (step.default as string);\n\n        if (step.validate?.required && !actualValue) {\n          return 'This field is required';\n        }\n        if (step.validate?.pattern && actualValue) {\n          const regex = new RegExp(step.validate.pattern);\n          if (!regex.test(actualValue)) {\n            return `Must match pattern: ${step.validate.pattern}`;\n          }\n        }\n      },\n    });\n\n    abortIfCancel(input);\n\n    answer = input || step.default;\n  } else if (step.promptType === 'select' && step.options) {\n    answer = await select({\n      message: step.message,\n      options: step.options,\n    });\n\n    abortIfCancel(answer);\n  } else if (step.promptType === 'confirm') {\n    answer = await confirm({\n      message: step.message,\n    });\n    abortIfCancel(answer);\n  } else if (step.promptType === 'file-search') {\n    const pattern = step.pattern || '**/*';\n    const exclude = step.exclude || ['node_modules', 'dist', '.git'];\n\n    const files = await glob(pattern, {\n      cwd,\n      ignore: exclude,\n      dot: false,\n      absolute: false,\n    });\n\n    if (files.length === 0) {\n      answer = await text({\n        message: step.message,\n        defaultValue: step.default as string,\n      });\n    } else {\n      // Sort & limit results (biar gak overwhelming)\n      const sortedFiles = files.sort((a, b) => a.localeCompare(b)).slice(0, 20); // ← max 20 files\n\n      const options = sortedFiles.map((f) => ({\n        value: f,\n        label: f,\n      }));\n\n      options.push({\n        value: '__custom__',\n        label: 'Enter custom path...',\n      });\n\n      const selected = await select({\n        message: step.message,\n        options,\n      });\n\n      abortIfCancel(selected);\n\n      if (selected === '__custom__') {\n        answer = await text({\n          message: 'Enter file path:',\n          defaultValue: step.default as string,\n        });\n\n        abortIfCancel(answer);\n      } else {\n        answer = selected;\n      }\n    }\n  }\n\n  if (answer !== undefined) {\n    setNestedValue(context, step.saveAs || step.name, answer);\n  }\n}\n\nasync function executeFileAppend(\n  step: Extract<SetupStep, { type: 'file-append' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  if (!existsSync(targetPath)) {\n    throw new Error(`File not found: ${target}`);\n  }\n\n  const content = step.content || (await getContent(step.contentPath!));\n  const existing = await fs.readFile(targetPath, 'utf-8');\n\n  const newContent = existing + '\\n' + content;\n\n  await fs.writeFile(targetPath, newContent, 'utf-8');\n\n  if (step.saveTargetAs) {\n    saveTargetAs(context, step.saveTargetAs, target);\n  }\n}\n\nasync function executeFileCreate(\n  step: Extract<SetupStep, { type: 'file-create' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  if (existsSync(targetPath) && !step.overwrite) {\n    const shouldOverwrite = await confirm({\n      message: `File \\`${target}\\` already exists. Overwrite?`,\n      initialValue: false,\n    });\n\n    if (!shouldOverwrite) {\n      return;\n    }\n  }\n\n  const content = step.content || (await getContent(step.contentPath!));\n\n  await fs.mkdir(path.dirname(targetPath), { recursive: true });\n  await fs.writeFile(targetPath, content, 'utf-8');\n\n  if (step.saveTargetAs) {\n    saveTargetAs(context, step.saveTargetAs, target);\n  }\n}\n\nasync function executeFileUpdate(\n  step: Extract<SetupStep, { type: 'file-update' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  if (!existsSync(targetPath)) {\n    throw new Error(`File not found: ${target}`);\n  }\n\n  let content = await fs.readFile(targetPath, 'utf-8');\n\n  // Apply replacement\n  const searchRegex = new RegExp(step.search, 'gms');\n\n  if (!searchRegex.test(content)) {\n    // log.warn(`Pattern not found in ${target}, skipping...`);\n    return;\n  }\n\n  const newContent = content.replace(searchRegex, step.replace);\n\n  await fs.writeFile(targetPath, newContent, 'utf-8');\n  log.success(`Updated ${target}`);\n\n  if (step.saveTargetAs) {\n    saveTargetAs(context, step.saveTargetAs, target);\n  }\n}\n\nasync function executeFileUpdateJson(\n  step: Extract<SetupStep, { type: 'file-update-json' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  let existing = {};\n\n  if (existsSync(targetPath)) {\n    const content = await fs.readFile(targetPath, 'utf-8');\n    existing = JSON.parse(content);\n  }\n\n  const merged =\n    step.merge === 'deep'\n      ? defu(step.content, existing)\n      : { ...existing, ...step.content };\n\n  await fs.writeFile(targetPath, JSON.stringify(merged, null, 2), 'utf-8');\n\n  if (step.saveTargetAs) {\n    saveTargetAs(context, step.saveTargetAs, target);\n  }\n}\n\nfunction interpolate(str: string, context: SetupContext): string {\n  return str.replace(/\\{\\{([^}]+)\\}\\}/g, (match, key) => {\n    const trimmedKey = key.trim();\n\n    // Try direct access first\n    let value = getNestedValue(context, trimmedKey);\n\n    // If not found and key doesn't have dots, try inside 'paths'\n    if (value === undefined && !trimmedKey.includes('.')) {\n      value = getNestedValue(context, `paths.${trimmedKey}`);\n    }\n\n    return value !== undefined ? value : match;\n  });\n}\n\nasync function getContent(contentPath: string): Promise<string> {\n  const filePath = path.join(process.cwd(), contentPath);\n\n  try {\n    return await fs.readFile(filePath, 'utf-8');\n  } catch (error) {\n    throw new Error(\n      `Failed to read content from ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\nfunction getNestedValue(obj: any, path: string): any {\n  return path.split('.').reduce((current, key) => current?.[key], obj);\n}\n\nfunction setNestedValue(obj: any, path: string, value: any): void {\n  const keys = path.split('.');\n  let current = obj;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    if (!current[keys[i]]) {\n      current[keys[i]] = {};\n    }\n    current = current[keys[i]];\n  }\n\n  current[keys[keys.length - 1]] = value;\n}\n\nasync function evaluateCondition(\n  condition: any,\n  context: any,\n  cwd: string,\n): Promise<boolean> {\n  // logical operators\n  if ('all' in condition) {\n    for (const c of condition.all) {\n      if (!(await evaluateCondition(c, context, cwd))) return false;\n    }\n    return true;\n  }\n\n  if ('any' in condition) {\n    for (const c of condition.any) {\n      if (await evaluateCondition(c, context, cwd)) return true;\n    }\n    return false;\n  }\n\n  if ('not' in condition) {\n    return !(await evaluateCondition(condition.not, context, cwd));\n  }\n\n  // atoms\n  switch (condition.type) {\n    case 'file-exists': {\n      return existsSync(path.join(cwd, interpolate(condition.path, context)));\n    }\n\n    case 'file-contains': {\n      const fullPath = path.join(cwd, interpolate(condition.path, context));\n      if (!existsSync(fullPath)) return false;\n\n      const content = await fs.readFile(fullPath, 'utf-8');\n      const regex = new RegExp(condition.pattern, 'm');\n      return regex.test(content);\n    }\n\n    case 'dependency': {\n      try {\n        const pkg = JSON.parse(\n          await fs.readFile(path.join(cwd, 'package.json'), 'utf-8'),\n        );\n        return (\n          pkg.dependencies?.[condition.name] ||\n          pkg.devDependencies?.[condition.name]\n        );\n      } catch {\n        return false;\n      }\n    }\n\n    case 'env':\n      return process.env[condition.key] !== undefined;\n\n    case 'framework':\n      return context.framework === condition.value;\n\n    default:\n      throw new Error(`Unknown condition type: ${condition.type}`);\n  }\n}\n\nasync function shouldRunStep(\n  step: SetupStep,\n  context: SetupContext,\n  cwd: string,\n): Promise<boolean> {\n  if (!step.condition) return true;\n\n  if (step.condition.if) {\n    const ok = await evaluateCondition(step.condition.if, context, cwd);\n    if (!ok) return false;\n  }\n\n  if (step.condition.unless) {\n    const blocked = await evaluateCondition(\n      step.condition.unless,\n      context,\n      cwd,\n    );\n    if (blocked) return false;\n  }\n\n  return true;\n}\n\nasync function resolveRunnableSteps(\n  setup: Setup,\n  context: SetupContext,\n  cwd: string,\n) {\n  const result: SetupStep[] = [];\n\n  for (const step of setup.steps) {\n    if (await shouldRunStep(step, context, cwd)) {\n      result.push(step);\n    }\n  }\n\n  return result;\n}\n\nfunction saveTargetAs(\n  context: SetupContext,\n  name: string | string[],\n  value: string,\n) {\n  if (Array.isArray(name)) {\n    for (const n of name) {\n      setNestedValue(context, n, value);\n    }\n    return;\n  }\n\n  setNestedValue(context, name, value);\n}\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { glob } from 'glob';\n\nasync function exists(p: string) {\n  try {\n    await fs.access(p);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function detectFramework(\n  cwd: string = process.cwd(),\n): Promise<[string, string]> {\n  try {\n    const pkgPath = path.join(cwd, 'package.json');\n    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));\n\n    const deps = {\n      ...pkg.dependencies,\n      ...pkg.devDependencies,\n    };\n\n    /* ----------------------------\n     * React meta-frameworks\n     * ---------------------------- */\n\n    if (deps['next']) {\n      const files = await glob('{pages,src/pages}/_app.{js,ts,jsx,tsx}', {\n        cwd,\n      });\n\n      if (files.length > 0) {\n        return ['next-pages', 'Next.js Pages'];\n      }\n      return ['next', 'Next.js'];\n    }\n\n    // React Router v7 (ex-Remix)\n    if (deps['react-router'] && deps['@react-router/dev']) {\n      return ['react-router', 'React Router v7'];\n    }\n\n    // Remix (legacy but still exists)\n    if (deps['@remix-run/react']) return ['remix', 'Remix'];\n\n    // TanStack Start\n    if (deps['@tanstack/react-start'])\n      return ['tanstack-start', 'TanStack Start'];\n\n    // TanStack Router (standalone)\n    if (deps['@tanstack/react-router'])\n      return ['tanstack-router', 'TanStack Router'];\n\n    // Astro\n    if (deps['astro']) return ['astro', 'Astro'];\n\n    /* ----------------------------\n     * Vite (needs file hint)\n     * ---------------------------- */\n\n    if (\n      deps['vite'] &&\n      ((await exists(path.join(cwd, 'vite.config.ts'))) ||\n        (await exists(path.join(cwd, 'vite.config.js'))))\n    ) {\n      return ['vite', 'Vite'];\n    }\n\n    /* ----------------------------\n     * Laravel (non-Node primary)\n     * ---------------------------- */\n\n    if (\n      (await exists(path.join(cwd, 'artisan'))) &&\n      (await exists(path.join(cwd, 'composer.json')))\n    ) {\n      return ['laravel', 'Laravel'];\n    }\n\n    /* ----------------------------\n     * Plain React fallback\n     * ---------------------------- */\n\n    if (deps['react']) return ['react', 'React'];\n\n    return ['unknown', 'Unknown'];\n  } catch {\n    return ['unknown', 'Unknown'];\n  }\n}\n","import { join } from 'node:path';\nimport { existsSync } from 'node:fs';\n\nexport function detectWorkdir(cwd: string) {\n  if (existsSync(join(cwd, 'src'))) {\n    return './src/';\n  }\n\n  return './';\n}\n","import deepmerge from 'deepmerge';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { Config } from '~/schemas/config-schema';\n\nexport async function writeConfig(config: Config) {\n  // read existing config\n  let existingConfig;\n  try {\n    existingConfig = await fs.readFile(\n      path.join(process.cwd(), 'selia.json'),\n      'utf-8',\n    );\n  } catch (error) {\n    existingConfig = '{}';\n  }\n\n  // merge configs\n  const mergedConfig = deepmerge(JSON.parse(existingConfig), config);\n\n  const configPath = path.join(process.cwd(), 'selia.json');\n  await fs.writeFile(\n    configPath,\n    JSON.stringify(mergedConfig, null, 2),\n    'utf-8',\n  );\n\n  return configPath;\n}\n","import { Command } from 'commander';\nimport { intro, outro, log } from '@clack/prompts';\nimport fs from 'fs/promises';\nimport picocolors from 'picocolors';\nimport { RegistrySchema } from '../schemas/registry-schema';\nimport { isRegistryExists } from '~/lib/utils';\nimport { cleanBuild } from '~/lib/clean-build';\nimport { buildRegistry } from '../lib/build-registry';\n\nexport const buildCommand = new Command()\n  .name('build')\n  .description('Build the registry')\n  .option('-o, --output <path>', 'Output directory', './public/registry')\n  .action(async (options) => {\n    console.log();\n    intro(picocolors.bgBlue(picocolors.blackBright(' Build Registry ')));\n\n    log.warn(\n      picocolors.yellow('This feature is not yet available for public use.'),\n    );\n\n    try {\n      // Check if registry exists\n      if (!(await isRegistryExists())) {\n        log.error(picocolors.red('Registry file not found: registry.json'));\n        console.log();\n        process.exit(1);\n      }\n\n      // Read and parse registry\n      const registryContent = await fs.readFile('./registry.json', 'utf-8');\n      const parsedRegistry = JSON.parse(registryContent);\n\n      // Validate registry\n      const validatedRegistry = RegistrySchema.safeParse(parsedRegistry);\n\n      if (!validatedRegistry.success) {\n        console.log(validatedRegistry.error);\n        log.error(picocolors.red('Invalid registry format:'));\n        validatedRegistry.error.issues.forEach((err) => {\n          log.error(\n            picocolors.red(`  - ${err.path.join('.')}: ${err.message}`),\n          );\n        });\n        process.exit(1);\n      }\n\n      // Clean output directory\n      await cleanBuild(options.output);\n\n      // Build registry\n      await buildRegistry(validatedRegistry.data, {\n        output: options.output,\n      });\n\n      outro(picocolors.green('Registry built successfully! ✓'));\n    } catch (error) {\n      log.error(\n        picocolors.red(\n          error instanceof Error ? error.message : 'An unknown error occurred',\n        ),\n      );\n      process.exit(1);\n    }\n  });\n","import { z } from 'zod';\nimport { ItemSchema } from './item-schema';\nimport { SetupSchema } from '~/schemas/setup-schema';\n\nexport const RegistrySchema = z.object({\n  name: z.string(),\n  homepage: z.url().optional(),\n  items: z.array(ItemSchema),\n  setup: z.union([SetupSchema, z.string()]).optional(),\n});\n\nexport type Registry = z.infer<typeof RegistrySchema>;\n","import fs from 'fs/promises';\n\nexport async function cleanBuild(output: string) {\n  await fs.rm(output, { recursive: true, force: true }).catch(() => {});\n\n  await fs.mkdir(output, { recursive: true }).catch(() => {});\n}\n","import fs from 'fs/promises';\nimport path from 'path';\nimport { Registry } from '../schemas/registry-schema';\nimport { Item } from '../schemas/item-schema';\nimport { log, spinner } from '@clack/prompts';\nimport picocolors from 'picocolors';\nimport type { Setup } from '../schemas/setup-schema';\n\ninterface BuildRegistryOptions {\n  output: string;\n}\n\nexport async function buildRegistry(\n  registry: Registry,\n  options: BuildRegistryOptions,\n) {\n  const s = spinner();\n  s.start('Building registry...');\n\n  try {\n    // Build registry.json\n    await buildRegistryFile(registry, options.output);\n\n    // Build individual items\n    for (let i = 0; i < registry.items.length; i++) {\n      const item = registry.items[i];\n      s.message(`Building ${item.name} (${i + 1}/${registry.items.length})`);\n      await buildItem(item, options.output);\n    }\n\n    // Build setup if exists\n    if (registry.setup) {\n      s.message('Building setup configuration...');\n      await buildSetup(registry.setup, options.output);\n    }\n\n    s.stop('Build complete');\n    log.success(\n      picocolors.green(`Built ${registry.items.length} items successfully`),\n    );\n  } catch (error) {\n    s.stop('Build failed');\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    log.error(picocolors.red(message));\n    process.exit(1);\n  }\n}\n\nasync function buildRegistryFile(\n  registry: Registry,\n  output: string,\n): Promise<void> {\n  // Remove file paths from registry.json (keep metadata only)\n  const cleanedItems = registry.items.map((item) => ({\n    ...item,\n    files: item.files.map(({ path: _, ...file }) => file),\n  }));\n\n  const cleanedRegistry = {\n    ...registry,\n    items: cleanedItems,\n  };\n\n  if (registry.setup) {\n    cleanedRegistry.setup = 'setup.json';\n  }\n\n  await fs.mkdir(output, { recursive: true });\n  await fs.writeFile(\n    path.join(output, 'registry.json'),\n    JSON.stringify(cleanedRegistry, null, 2),\n    'utf-8',\n  );\n}\n\nasync function buildItem(item: Item, output: string): Promise<void> {\n  const filesWithContent = await Promise.all(\n    item.files.map(async (file) => {\n      if (!file.path) {\n        throw new Error(`Path is required for file in item \"${item.name}\"`);\n      }\n\n      const rawContent = await fs.readFile(file.path, 'utf-8');\n      const content = rawContent.replace(/\\r/g, '').trim();\n\n      const { path: _, ...rest } = file;\n\n      return {\n        ...rest,\n        content,\n      };\n    }),\n  );\n\n  const itemWithContent = {\n    ...item,\n    files: filesWithContent,\n  };\n\n  await fs.mkdir(output, { recursive: true });\n  await fs.writeFile(\n    path.join(output, `${item.name}.json`),\n    JSON.stringify(itemWithContent, null, 2),\n    'utf-8',\n  );\n}\n\nasync function buildSetup(setup: Setup, output: string): Promise<void> {\n  // Process setup steps and resolve contentPath\n  const processedSteps = await Promise.all(\n    setup.steps.map(async (step) => {\n      // Only process steps with contentPath\n      if (\n        'contentPath' in step &&\n        step.contentPath &&\n        (step.type === 'file-append' || step.type === 'file-create')\n      ) {\n        try {\n          const content = await fs.readFile(step.contentPath, 'utf-8');\n          const { contentPath: _, ...rest } = step;\n\n          return {\n            ...rest,\n            content,\n          };\n        } catch (error) {\n          throw new Error(\n            `Failed to read content for setup step from \"${step.contentPath}\": ${error instanceof Error ? error.message : 'Unknown error'\n            }`,\n          );\n        }\n      }\n\n      return step;\n    }),\n  );\n\n  const processedSetup = {\n    steps: processedSteps,\n  };\n\n  await fs.writeFile(\n    path.join(output, 'setup.json'),\n    JSON.stringify(processedSetup, null, 2),\n    'utf-8',\n  );\n}\n\nasync function processSetupPaths(setup: Setup): Promise<Setup> {\n  const processedSteps = setup.steps.map((step) => {\n    if ('contentPath' in step && step.contentPath) {\n      const { contentPath: _, content: __, ...rest } = step as any;\n      return rest;\n    }\n\n    if ('content' in step && step.content) {\n      const { content: _, ...rest } = step as any;\n      return rest;\n    }\n\n    return step;\n  });\n\n  return {\n    steps: processedSteps,\n  };\n}\n"],"mappings":"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","names":["spinner","log","fs","path","z","z","path","fs","path","fs","path","fs","existsSync","fs","path","log","existsSync","path","spinner","fs","Command","intro","outro","log","spinner","confirm","picocolors","z","fs","existsSync","path","glob","select","log","defu","fs","path","existsSync","picocolors","existsSync","path","fs","log","select","glob","defu","fs","path","Command","intro","picocolors","log","outro","spinner","confirm","Command","intro","outro","log","fs","picocolors","z","z","fs","fs","path","log","spinner","picocolors","Command","intro","picocolors","log","fs","outro"]}