{"version":3,"sources":["../src/lib/setup-executor.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport { existsSync } from 'fs';\nimport path from 'path';\nimport { glob } from 'glob';\nimport { text, select, confirm, log } from '@clack/prompts';\nimport { defu } from 'defu';\nimport type { Setup, SetupStep } from '../schemas/setup-schema';\nimport { detectFramework } from './detect-framework';\nimport { installDependencies } from './install-dependencies';\nimport { abortIfCancel } from '~/lib/utils';\n\nexport interface SetupContext {\n  [key: string]: any;\n}\n\ninterface ExecutorOptions {\n  cwd?: string;\n}\n\nconst executable = ['prompt', 'detect-framework', 'assert'];\n\nexport async function executeSetup(\n  setup: Setup,\n  options: ExecutorOptions = {},\n): Promise<SetupContext> {\n  const context: SetupContext = {};\n  const cwd = options.cwd || process.cwd();\n  const steps = await resolveRunnableSteps(setup, context, cwd);\n\n  // Phase 1: Collect information (prompts & detect)\n  for (const step of steps) {\n    if (executable.includes(step.type)) {\n      await executeStep(step, context, cwd);\n    }\n  }\n\n  return context;\n}\n\nexport async function executeSetupActions(\n  setup: Setup,\n  context: SetupContext,\n  options: ExecutorOptions = {},\n): Promise<void> {\n  const cwd = options.cwd || process.cwd();\n  const steps = await resolveRunnableSteps(setup, context, cwd);\n\n  // Phase 2: Execute actions (dependencies, files, etc)\n  for (const step of steps) {\n    // Skip prompts (already done)\n    if (executable.includes(step.type)) {\n      continue;\n    }\n\n    await executeStep(step, context, cwd);\n  }\n}\n\nexport async function previewSetupActions(\n  setup: Setup,\n  context: SetupContext,\n  options: ExecutorOptions = {},\n): Promise<string[]> {\n  const actions: string[] = [];\n  const cwd = options.cwd || process.cwd();\n  const steps = await resolveRunnableSteps(setup, context, cwd);\n\n  for (const step of steps) {\n    if (step.type === 'dependencies') {\n      const count = Object.keys(step.packages).length;\n      actions.push(\n        `Install ${count} required npm package${count > 1 ? 's' : ''}`,\n      );\n    } else if (step.type === 'file-create') {\n      const target = interpolate(step.target, context);\n      actions.push(`Create \\`${target}\\``);\n    } else if (step.type === 'file-append') {\n      const target = interpolate(step.target, context);\n      actions.push(`Append to \\`${target}\\``);\n    } else if (step.type === 'file-update') {\n      const target = interpolate(step.target, context);\n      actions.push(`Update \\`${target}\\``);\n    } else if (step.type === 'file-update-json') {\n      const target = interpolate(step.target, context);\n      actions.push(`Update \\`${target}\\``);\n    }\n  }\n\n  return actions;\n}\n\nasync function executeStep(\n  step: SetupStep,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  switch (step.type) {\n    case 'assert':\n      await executeAssert(step, context, cwd);\n      break;\n    case 'dependencies':\n      await executeDependencies(step, cwd);\n      break;\n    case 'detect-framework':\n      await executeDetectFramework(step, context, cwd);\n      break;\n    case 'prompt':\n      await executePrompt(step, context, cwd);\n      break;\n    case 'file-append':\n      await executeFileAppend(step, context, cwd);\n      break;\n    case 'file-create':\n      await executeFileCreate(step, context, cwd);\n      break;\n    case 'file-update':\n      await executeFileUpdate(step, context, cwd);\n      break;\n    case 'file-update-json':\n      await executeFileUpdateJson(step, context, cwd);\n      break;\n  }\n}\n\nasync function executeAssert(\n  step: Extract<SetupStep, { type: 'assert' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const ok = await runAssertCheck(step.check, context, cwd);\n\n  if (!ok) {\n    const message = Array.isArray(step.onFail.message)\n      ? step.onFail.message.join('\\n')\n      : step.onFail.message;\n\n    if (step.onFail?.exit !== false) {\n      throw new Error(message);\n    }\n\n    // console.warn(message);\n  }\n}\n\nasync function runAssertCheck(\n  check: any,\n  context: SetupContext,\n  cwd: string,\n): Promise<boolean> {\n  switch (check.type) {\n    case 'dependency':\n      return checkDependencies(check.packages, cwd);\n\n    case 'file-exists':\n      return existsSync(path.join(cwd, check.path));\n\n    case 'framework':\n      return check.value.includes(context.framework);\n\n    case 'env':\n      return process.env[check.key] !== undefined;\n\n    default:\n      throw new Error(`Unknown assert check type: ${check.type}`);\n  }\n}\n\nasync function checkDependencies(\n  packages: string[],\n  cwd: string,\n): Promise<boolean> {\n  try {\n    const pkgPath = path.join(cwd, 'package.json');\n    const pkg = JSON.parse(await fs.readFile(pkgPath, 'utf-8'));\n\n    const deps = {\n      ...pkg.dependencies,\n      ...pkg.devDependencies,\n    };\n\n    return packages.every((name) => deps[name]);\n  } catch {\n    return false;\n  }\n}\n\nasync function executeDependencies(\n  step: Extract<SetupStep, { type: 'dependencies' }>,\n  cwd: string,\n): Promise<void> {\n  await installDependencies(step.packages, cwd);\n}\n\nasync function executeDetectFramework(\n  step: Extract<SetupStep, { type: 'detect-framework' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const framework = await detectFramework(cwd);\n  const saveAs = step.saveAs || step.name;\n  setNestedValue(context, saveAs, framework);\n}\n\nasync function executePrompt(\n  step: Extract<SetupStep, { type: 'prompt' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  let answer: any;\n\n  if (step.promptType === 'text') {\n    const input = await text({\n      message: step.message,\n      placeholder: step.default as string,\n      validate: (value) => {\n        const actualValue = value || (step.default as string);\n\n        if (step.validate?.required && !actualValue) {\n          return 'This field is required';\n        }\n        if (step.validate?.pattern && actualValue) {\n          const regex = new RegExp(step.validate.pattern);\n          if (!regex.test(actualValue)) {\n            return `Must match pattern: ${step.validate.pattern}`;\n          }\n        }\n      },\n    });\n\n    abortIfCancel(input);\n\n    answer = input || step.default;\n  } else if (step.promptType === 'select' && step.options) {\n    answer = await select({\n      message: step.message,\n      options: step.options,\n    });\n\n    abortIfCancel(answer);\n  } else if (step.promptType === 'confirm') {\n    answer = await confirm({\n      message: step.message,\n    });\n    abortIfCancel(answer);\n  } else if (step.promptType === 'file-search') {\n    const pattern = step.pattern || '**/*';\n    const exclude = step.exclude || ['node_modules', 'dist', '.git'];\n\n    const files = await glob(pattern, {\n      cwd,\n      ignore: exclude,\n      dot: false,\n      absolute: false,\n    });\n\n    if (files.length === 0) {\n      answer = await text({\n        message: step.message,\n        defaultValue: step.default as string,\n      });\n    } else {\n      // Sort & limit results (biar gak overwhelming)\n      const sortedFiles = files.sort((a, b) => a.localeCompare(b)).slice(0, 20); // â† max 20 files\n\n      const options = sortedFiles.map((f) => ({\n        value: f,\n        label: f,\n      }));\n\n      options.push({\n        value: '__custom__',\n        label: 'Enter custom path...',\n      });\n\n      const selected = await select({\n        message: step.message,\n        options,\n      });\n\n      abortIfCancel(selected);\n\n      if (selected === '__custom__') {\n        answer = await text({\n          message: 'Enter file path:',\n          defaultValue: step.default as string,\n        });\n\n        abortIfCancel(answer);\n      } else {\n        answer = selected;\n      }\n    }\n  }\n\n  if (answer !== undefined) {\n    setNestedValue(context, step.saveAs || step.name, answer);\n  }\n}\n\nasync function executeFileAppend(\n  step: Extract<SetupStep, { type: 'file-append' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  if (!existsSync(targetPath)) {\n    throw new Error(`File not found: ${target}`);\n  }\n\n  const content = step.content || (await getContent(step.contentPath!));\n  const existing = await fs.readFile(targetPath, 'utf-8');\n\n  const newContent = existing + '\\n' + content;\n\n  await fs.writeFile(targetPath, newContent, 'utf-8');\n}\n\nasync function executeFileCreate(\n  step: Extract<SetupStep, { type: 'file-create' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  if (existsSync(targetPath) && !step.overwrite) {\n    const shouldOverwrite = await confirm({\n      message: `File \\`${target}\\` already exists. Overwrite?`,\n    });\n\n    if (!shouldOverwrite) {\n      return;\n    }\n  }\n\n  const content = step.content || (await getContent(step.contentPath!));\n\n  await fs.mkdir(path.dirname(targetPath), { recursive: true });\n  await fs.writeFile(targetPath, content, 'utf-8');\n}\n\nasync function executeFileUpdate(\n  step: Extract<SetupStep, { type: 'file-update' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  if (!existsSync(targetPath)) {\n    throw new Error(`File not found: ${target}`);\n  }\n\n  let content = await fs.readFile(targetPath, 'utf-8');\n\n  // Apply replacement\n  const searchRegex = new RegExp(step.search, 'gms');\n\n  if (!searchRegex.test(content)) {\n    // log.warn(`Pattern not found in ${target}, skipping...`);\n    return;\n  }\n\n  const newContent = content.replace(searchRegex, step.replace);\n\n  await fs.writeFile(targetPath, newContent, 'utf-8');\n  log.success(`Updated ${target}`);\n}\n\nasync function executeFileUpdateJson(\n  step: Extract<SetupStep, { type: 'file-update-json' }>,\n  context: SetupContext,\n  cwd: string,\n): Promise<void> {\n  const target = interpolate(step.target, context);\n  const targetPath = path.join(cwd, target);\n\n  let existing = {};\n\n  if (existsSync(targetPath)) {\n    const content = await fs.readFile(targetPath, 'utf-8');\n    existing = JSON.parse(content);\n  }\n\n  const merged =\n    step.merge === 'deep'\n      ? defu(step.content, existing)\n      : { ...existing, ...step.content };\n\n  await fs.writeFile(targetPath, JSON.stringify(merged, null, 2), 'utf-8');\n}\n\nfunction interpolate(str: string, context: SetupContext): string {\n  return str.replace(/\\{\\{([^}]+)\\}\\}/g, (match, key) => {\n    const trimmedKey = key.trim();\n\n    // Try direct access first\n    let value = getNestedValue(context, trimmedKey);\n\n    // If not found and key doesn't have dots, try inside 'paths'\n    if (value === undefined && !trimmedKey.includes('.')) {\n      value = getNestedValue(context, `paths.${trimmedKey}`);\n    }\n\n    return value !== undefined ? value : match;\n  });\n}\n\nasync function getContent(contentPath: string): Promise<string> {\n  const filePath = path.join(process.cwd(), contentPath);\n\n  try {\n    return await fs.readFile(filePath, 'utf-8');\n  } catch (error) {\n    throw new Error(\n      `Failed to read content from ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\nfunction getNestedValue(obj: any, path: string): any {\n  return path.split('.').reduce((current, key) => current?.[key], obj);\n}\n\nfunction setNestedValue(obj: any, path: string, value: any): void {\n  const keys = path.split('.');\n  let current = obj;\n\n  for (let i = 0; i < keys.length - 1; i++) {\n    if (!current[keys[i]]) {\n      current[keys[i]] = {};\n    }\n    current = current[keys[i]];\n  }\n\n  current[keys[keys.length - 1]] = value;\n}\n\nasync function evaluateCondition(\n  condition: any,\n  context: any,\n  cwd: string,\n): Promise<boolean> {\n  // logical operators\n  if ('all' in condition) {\n    for (const c of condition.all) {\n      if (!(await evaluateCondition(c, context, cwd))) return false;\n    }\n    return true;\n  }\n\n  if ('any' in condition) {\n    for (const c of condition.any) {\n      if (await evaluateCondition(c, context, cwd)) return true;\n    }\n    return false;\n  }\n\n  if ('not' in condition) {\n    return !(await evaluateCondition(condition.not, context, cwd));\n  }\n\n  // atoms\n  switch (condition.type) {\n    case 'file-exists': {\n      return existsSync(path.join(cwd, interpolate(condition.path, context)));\n    }\n\n    case 'file-contains': {\n      const fullPath = path.join(cwd, interpolate(condition.path, context));\n      if (!existsSync(fullPath)) return false;\n\n      const content = await fs.readFile(fullPath, 'utf-8');\n      const regex = new RegExp(condition.pattern, 'm');\n      return regex.test(content);\n    }\n\n    case 'dependency': {\n      try {\n        const pkg = JSON.parse(\n          await fs.readFile(path.join(cwd, 'package.json'), 'utf-8'),\n        );\n        return (\n          pkg.dependencies?.[condition.name] ||\n          pkg.devDependencies?.[condition.name]\n        );\n      } catch {\n        return false;\n      }\n    }\n\n    case 'env':\n      return process.env[condition.key] !== undefined;\n\n    case 'framework':\n      return context.framework === condition.value;\n\n    default:\n      throw new Error(`Unknown condition type: ${condition.type}`);\n  }\n}\n\nasync function shouldRunStep(\n  step: SetupStep,\n  context: SetupContext,\n  cwd: string,\n): Promise<boolean> {\n  if (!step.condition) return true;\n\n  if (step.condition.if) {\n    const ok = await evaluateCondition(step.condition.if, context, cwd);\n    if (!ok) return false;\n  }\n\n  if (step.condition.unless) {\n    const blocked = await evaluateCondition(\n      step.condition.unless,\n      context,\n      cwd,\n    );\n    if (blocked) return false;\n  }\n\n  return true;\n}\n\nasync function resolveRunnableSteps(\n  setup: Setup,\n  context: SetupContext,\n  cwd: string,\n) {\n  const result: SetupStep[] = [];\n\n  for (const step of setup.steps) {\n    if (await shouldRunStep(step, context, cwd)) {\n      result.push(step);\n    }\n  }\n\n  return result;\n}\n"],"mappings":"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","names":["path"]}